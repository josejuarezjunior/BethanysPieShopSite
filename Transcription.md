# **Building Websites with HTML, CSS, and JavaScript: Getting Started**

Course Overview
Course Overview
Welcome to Building Websites with HTML, CSS, and JavaScript: Getting Started. This course is special because it takes you on a journey that assumes you're starting from the very beginning when it comes to building websites. Here, you learn about the foundations of web development and how those concepts fit together to help you build a functioning website from a blank page. Well, hello. I'm your instructor, Craig Shoemaker, and in this course you learn how HTML is the structure for a website's content, that CSS, or Cascading Style Sheets, are used to craft the look and feel of a website, and the very basics of computer programming and how to use JavaScript to add behavior and interactivity to your website. Now along the way, you'll learn to answer questions like, how do I build a web layout that works just as great on mobile devices as it does on the desktop? How do I collect user data for processing? How do I read the location of a visitor that comes to my website? And honestly, the list goes on and on. So by the end of this course, you learn to build an interactive website, but more than that, you have the understanding of the basics of programming and how each piece of the web development puzzle fits together so you can move forward on your journey to becoming a professional developer.

Getting Started
What You Learn
Hello, and welcome to Building Websites with HTML, CSS, and JavaScript: Getting Started. I'm really excited because you're about to take your first steps into becoming a web developer. Building websites requires a bit of knowledge among a number of different disciplines, and starting today, you begin learning about each of these building blocks step by step. You'll learn about how HTML is used to structure your site's content, how style sheets craft the look and feel of your site, and all about the web's programming language, JavaScript, which adds behavior and interactivity to your site. By the end of this course, you'll learn to build a website that rests firmly on these foundations, touches on some advanced browser features, and works just as well on mobile devices as it does on the desktop. Well, I'm Craig Shoemaker, and I'm delighted to teach you all about building websites with HTML, CSS, and JavaScript. Let's get started. Your close friend Bethany has a thriving local business selling what you consider to be the best pies ever baked. So when she mentioned that she wanted some help to take her pie shop online, well, you jump at the chance to help make her dream a reality. The home page welcomes customers with a warm greeting and an invitation to dive into her selection of pies. By clicking on the browse our pies link, a collection of available pies is listed on the page. From here, you have a chance to order Bethany's famous apple pie or the ever popular cherry pie. Clicking on one of the Order buttons takes us to the order page where the website asks for permission to read location data. And then from there, we can enter in our name, address, and any comments we want to share with Bethany. Now, before we send the order over, there's something happening inside the browser that I want you to see. I've opened up the browser developer tools, and now we can get an idea of how the information is saved in the browser to power our pies order page. Now, we'll get into the details of how all this works soon, but I want you to have a little bit of an understanding of what's happening behind the scenes. So if we go back to the order form, when we submit the form, all of the order information is sent to the server for processing. Now, since this course covers front‑end technologies, meaning the code that runs inside the browser and not on the web server, when we submit the form, I just have a utility running on my machine that displays that information back to us. So we can be sure we're sending all the information exactly as it needs to go to the server. So, we've got a lot of ground to cover. We'll talk about HTML, CSS, JavaScript, and everything needed in order to build this website from a blank page. So, to get you started in the right direction, let's start by writing your first bit of HTML.

Your First HTML Element
Okay, let's get started. Open up your browser, and make your way over to codepen.io/pen. From here, we'll expand the HTML pane and enter in <h1>. This is your first HTML element. The h stands for header, and 1 means that it's the primary, or first, header on the page. Now there's a lot packed into the significance of this element, but for now, suffice it to say, that the h1 header is essentially the title of your page. Next, let's add some text, Hello World. Now, as the story goes, an old programming book from the 70s first used Hello World to show the simplest possible program in a given language. So if you continue on to programming, you'll probably see this quite a bit. So now, to finish off the element, we'll add what's called the closing tag. And there it is. You've written your first bit of HTML. It's too soon to call it a web page, but we're getting there. So from this tiny example, you can start to see that websites are made up of elements that when they're stacked together in just the right way, they make up the foundation of the web. Now let's lean into this a little bit and get a few tools set up on your machine so you can start writing something that more resembles what you'll make in the real world. So, next up, you'll install a code editor named Visual Studio Code, along with a handy tool that makes it easy to see your code as it changes.

Set up Your Code Editor
There are a lot of amazing code editors available. Most are free and come with rich features and thriving communities. The editor I'll recommend for you for this course has become a favorite among developers worldwide, and just as promised, it's free and comes with an incredible set of features and a vibrant community. So point your browser to code.visualstudio.com, and from the home page, you'll see a Download button right there. Now I'm on a Windows machine, but this will point to a Mac or Linux installer, depending on the type of machine that you're on. So go ahead and download and install VS Code, and then I'll show you a tool that will make your life so much easier. So here I have VS Code installed and opened up. And what's great about VS Code is that it supports extensions. So if you take a look at the icon bar on the left, you'll see an icon that shows a box being snapped into another box. Well, if you click on this, it opens up VS Code's EXTENSIONS window. Extensions are great feature because that means that anyone can create additional functionality to VS Code, and it supports all kinds of extra features. So let's install an extension that opens up your code in a web browser in the same way a web server sends your pages to the browser, but you don't have to write any server‑related code. And the best part is that it listens for changes as you make them and automatically refreshes the window with your latest changes. It's pretty handy. So in the search box, we'll search for Live Server. From here, we'll click Install, and then for this extension, we'll reload the VS Code window. So within VS Code, we'll type Ctrl+Shift or Command+Shift+P, and it shows that I've recently done this, but if you start typing Reload Window, that option shows up for you underneath the search bar. So we'll press Enter, and now you can see down at the bottom of the window we have a Go Live button. All right, let's test this out. VS Code comes with some shortcuts that make it a little bit easier to write some HTML. So I'll start writing html, and you see that I have some options that drop down here. I'll select the one where it has :5, and then just down in the body, I'll type in Hello World again. From there, I'll save my changes, and then I can go over to the EXPLORER, right‑click on the file, and say, Open with Live Server. This launches the Live Server, and now my page is showing up within the browser window. And now watch this. Any time I make a change to this file and press Save, it automatically makes that change over in the browser. So now that Visual Studio Code is set up on your machine, we can set up the sample project on your machine as well.

Set up Your Project Files
Now with VS Code set up on your machine, we can go ahead and get the starting files that you need in order to work with this course. Now all the code is available up on GitHub under github.com/craigshoemaker/html‑css‑javascript‑getting‑started. Now, if you're not familiar with GitHub and how it works, no worries. I've got you covered. I just want you to know that all the code is here, and in fact, I even have something special set aside for you, which makes getting started very easy. If you go to this address, bit.ly/hcj‑start, that will automatically point to a file and allow you to download a ZIP that has all the starting files that you need for this course. So let's go ahead and do that. Now the ZIP file is downloaded to my machine. If I type Ctrl+J in the browser, that shows the file that I just downloaded. I can click Show in folder, and that takes me directly to the folder that it was saved in. From there, I can right‑click and choose Extract All. Then I can open up the folder that it created, and here's all the starting files. From here, I can copy the file location, go back to Visual Studio Code, select File, Open Folder, paste in that location, and now you can see that the images for our website, as well as placeholders for all the HTML files, are all available here within the starter files. So now with everything set up, in the next module, we'll begin writing your first page in the website.

Next Up
So now you've written a little bit of code, you've set up the editor, Visual Studio Code, on your machine, and you've got the project files ready to go. Now let's move on towards building your very first web page.

Building Your First Web Page
Introduction
In this module, you'll learn all about what HTML is, about its purpose, and how it interacts with different parts of a website. You'll become familiar with common elements and learn how search engines see a web page, as well as find out how to validate HTML code on your site. So, to begin, let's find out what HTML stands for and what it really is.

What Is HTML?
HTML stands for Hypertext Markup Language. Now, let's take that step by step. Hypertext is really one word and refers to the fact that on the web documents are linked together using what's called a hyperlink. Now taking the prefix hyper out of the equation for a moment, what we're really saying is that there are text documents that are connected together by links, and this is the foundation of the web. You might wonder, then, why is hyper part of the name? Well, hyper is used in the sense of making things bigger, like hyperspace, rather than what you think of when you hear the term like hyperactive. So as you navigate from one website to the next, they're all tied together through a series of links which conceptually web together, giving us the name the web" for the internet. Now markup language refers to the code that we write in order to create the documents, and in many cases that establishes links between these documents. Now, the building block for the markup language are what's called HTML elements. So let's zoom in a bit and take a look at what an element is.

What Is an HTML Element?
Now that you have the sense of what role HTML plays, let's talk about HTML elements. And elements is a building block of a web page. Much like a Lego brick is the building block of this town here, HTML elements are put together in order to build the structure of a web page. All right, well, let's take a look at it in the sense of a very simple website. Now, from this web page, we have a few options available to us in order to look at the underlying code. First, we can right‑click on the page and select view source. This opens a new tab with the HTML of the page. It's okay, and it works all right for a very small web page like this one. But once you move on to a real website, things can change just a little bit. For a more real‑world example, let's take a look at pluralsight.com. And we'll right‑click and choose View page source, and as we scroll here a little bit, you can see that quickly things get a little bit indecipherable, so let's close this out and try a different way. This time, instead of right‑clicking and choosing view source, I'm going to select Inspect. This opens up the Elements pane of the browser developer tools. You'll get to know these tools quite well during this course. From here you get a better sense of the page. The elements are collapsible, and even on a very, very big page I can scroll up to the top and get a sense of the structure of what's happening within this web page. Now I can hover over an element and select one, and what you see here is commonly called markup. And depending on what I select, if I hover over an element, it will highlight it in the page itself. So every HTML page is made up of a series of HTML elements that build on one another like a series of bricks that, when set together just right, make a house. So let's find out what makes each element different.

Elements, Tags, and Attributes
Returning back to the simple web page example, when we look at the page's HTML, you can see that it's made up of different elements. Now if we take a look at these elements just a little bit closer for the moment, you'll see that each element is made up from at least two parts. The first part is what's called a tag. While every page is made up of building blocks, which are the elements, each element is differentiated by its tag. An element's tag tells you what the element is and the different roles that it plays on the page. We'll dive into those roles and meanings in a moment, but for now, when we look at this page, you can see that it's built from a series of elements, where each one has its tag, html, head, title, body, h1, p, and img for images. Okay, let's look at the image element just a little bit closer. This element has the img tag, but it also has some additional information associated with it. The src and title parts of the element are what's known as attributes. Now this makes sense because if I wanted to describe myself to someone, I might say I'm a person, which equates to the elements tag, and I might say that my name is Craig, and I have brown eyes, and brown hair, and these are all attributes of who I am as a person. In similar fashion, the image element, which has the img tag, includes the src and title attributes. Now different attributes do different things. In the case of the image element, the src attribute tells the web browser where to look on the server for an image file. This way, if the image can be found by the browser, it knows how to display it on the screen. The title attribute gives us a title or a bit of description about the element. Notice how, when I hover over the image, the title appears, and the title attribute makes this possible. So HTML pages are made up from a series of building blocks called elements, each element is identified by its tag, and an element can have 0, 1, or many attributes. Now throughout the course, you're going to see a couple attributes over and over again, the id attribute and the class attributes. Id stands for identifier, and that will give a unique name to elements on the page. The class attributes can be used to identify an element and change how the element looks on the page using style sheets, and again we'll get into that a lot more as the course goes on, but for now, you have a much better idea of the difference between elements, tags, and attributes. So now let's look at how to use some common elements.

About Common Elements
Now, when I talk about there being building blocks for a web page, there are many blocks to choose from. Here I am on the HTML elements references on the Mozilla Developers Network, and the MDN web docs are the place to go when you want to learn about HTML elements and web APIs. Now I won't go over each one of the elements, but on this page you can find all you need to know about each element that's available to you in HTML5. So every page will start off with an HTML element. Usually there's a head element in there as well, along with a body element, and you've seen these in the examples that I've shown you so far. But then things start to get a little more granular. So there's content sectioning elements, elements specifically for text content, elements for inline text. And what we mean by semantics here is by using elements that describe information about the text that's within a web page. We'll get into this more as we go along. Image and multimedia elements, embedded content. These are for a few of your more advanced scenarios. Scripting, which you'll get familiar with in this course. Ways of showing edits; presenting tabular information; web forms, the way that you're going to collect user data; elements that allow you to interact with the page; Web Components that give you the chance to create custom elements, and then, of course, the elements that we no longer support on the web. So as you journey through learning about HTML, this reference can be very useful to you. All right, now let's use some of these elements on a page.

Using Common Elements
Now, along the way, I'd like to introduce you to my friend Emmet, and Emmet is a tool that's built into Visual Studio Code that makes it so much easier for you to write HTML code. Emmet is made out of shortcuts, so I can type a few characters, press the Tab key, and it'll fill in the rest for me. So here I want to start off by building the basics that I need for an HTML5 page. So here I'll type ht, and you can see the autocomplete even comes up, and I want an HTML5 page, so I can select html:5, and this creates a stub for the HTML page for me. Now within the body of the page, I can simply type h1, and when I hit Tab, that creates an h1 element for me, and it even positions my cursor between the two elements so I can start typing something that's wrapped around by that element. So here I'll give the page a title. On the next line, I want to add a paragraph to the page, so I can type P and press Tab, and this creates a paragraph element. And now I can give the paragraph some text. Now I want to create a link on my page. To do that, I'll use the anchor tag. Now, instead of typing out anchor, we've abbreviated it to just a, so I can create an a element, hit Tab, and this time, instead of just creating the element, it gives me an attribute as well. Now the href attribute stands for hyperlink reference. So what that means is that I can put a web address in there, and my link will point to that address when I click on it. So here, let's create a link to Pluralsight. And now, in between the opening and closing tag of the elements, I can add some text. Now I want to add a table. With Emmet's help, that becomes very easy. I can just type table. That creates the root table element. Now I'm going to create a header for the table. The abbreviation for that is thead for table head. Inside that header, I'd like to create a row, so this is the header row of the table. The row is a tr element for table row, and inside that row I want to create a header, so I'll do a th for header, and I'll give this a label of Author. The next thing I'll do is create a title header because we're creating a list of courses that you can find over on Pluralsight. So that's the header of the table, and now I can create the body of the table. Within the body I want to have a row, and within that row I need some table data. So the element for this is td. So I can type in an author name like Craig Shoemaker. I'll creates some more table data and paste in one of my course titles, like the one you're watching right now. Now it's not much of a table if it doesn't have a least another row of data, so I'll create another row, another cell for data, type in another Pluralsight author, let's go with John Papa, one more cell of data, and we'll point to his latest course, Vue: Getting Started. So now let's take a look at the result of this page. I'll right‑click on the page and come down and say, Open with Live Server. Well, here's our page, and yes, it is not much to look at. We'll get into styling the page in a moment. But here we've got a title on the page, we've got some paragraph worth of text, and a table that desperately needs some styling to make it look better. But nevertheless, it's a table. And we have our link, so when we click on it, we can learn more at Pluralsight. Next, let's look at how web browser uses this structure to create a version of the web page that it builds in memory and see how it uses this model to interact with the page.

Document Object Model (DOM)
Now the way a browser represents a web page in memory is through the Document Object Model. Now, if we talk about the document, every website is made up of a collection of web pages. Every web page is a single document. And inside the web browser, each page is represented by something in memory which is called document. If we go back to our really simple website and open up the developer tools, I'll right‑click and choose Inspect, and then come over to the Console. The Console is a place where I can write different commands, and the browser will tell me what the result is. So in here, I can type in document, and when I pressed Enter, you'll notice that it returns to me a reference to the document within the browser. Now, when I hover over it, it highlights the entire page. If I expand this item, you can see here that all of the HTML, essentially everything that you see within the Elements tab of the developer tools, is available through document. So the document object is what the browser uses to understand the web page as a whole. Now, I keep talking about this word object. In the world of computers, we have to find ways to make representations of things that exists either in the real world or just while the computer is working with something. One way to think about an object is that it's an approximation of something. For instance, if I ask you to think about a house, you probably think of walls and a roof and some windows and a door. But houses are really so much more than that. They're heating and cooling systems, and plumbing and electrical systems, and paint, and on and on. The point is, is that we think in terms of abstractions, meaning we often use placeholders for things that we either don't want to be bothered with the details of or things we don't understand at all. In the browser, each element is represented by an object, which is a way the browser uses to understand the structure created by the elements on a web page. Now, when we talk about model, this alludes to the fact that the DOM is a representation of that structure. Just like a model plane is a representation of the real thing, here we're using a series of objects in order to create a model of what really exists on the web page. So the browser uses the Document Object Model to understand, represent, and interface with the web page. You'll often see it reduced to the acronym of DOM, which is pronounced DOM. So if you like the DOM, it's a tree structure that represents the hierarchical nature of the structure of a web page. And looking back at our simple web page, you can see this hierarchy and how the page is represented in memory. Now it gets fun here, is that if you poke around a little bit, you'll notice over on the Elements tab, as I select different elements, this little gray $0 follows me around for any element that I select. So with this paragraph selected, if I go over to the Console and type in $0, it returns a reference to that element. So if I go back over to Elements and I select the header, the h1, and I do the same thing, type in $0, it returns a reference to the header. So this is a shortcut that the browser gives you in order to work with the DOM. Every time I select an element, it creates a little pointer to the selected item that you can access using $0. So what you're seeing here as we poke around a little bit is how the document is represented in the browser's memory. It just so happens that the model is rendered to us in the exact same markup we typed into the editor. Now, we'll spend a good amount of time in the developer tools using the DOM. So this is how the browser sees the web page, but how does a search engine see the web page when it reads its contents? Well, we'll look at that next.

How Search Engines See HTML
Now search engines see your web page differently than you do in the web browser. So we're just warming up to some of these concepts, and I want to state upfront that I'm simplifying things a lot in attempt to make this easy to understand from the very basics. There's an entire art and science involved with working with and ranking in search engines. I'm going to sidestep all of that for a moment and just look at the very small slice of search engine functionality of what the search engine does when it looks at your web page. So it's a good time to introduce a new term, semantic markup. Semantic markup doesn't use any special HTML elements, but it more refers to how you use the elements together. Let's look at this HTML fragment. Introduction. Once upon a time, there was a beautiful princess who lived happily ever after. This is a short bedtime story I tell my daughter from time to time when it's too late to tell a real story. Well, as far as the HTML is concerned, there's a problem with this structure. There's no way to tell the relative significance of one piece of content from the next. What I mean by that is that a computer can't tell that the word Introduction is a title and that it has a nuanced meaning that's different from the text that's in the paragraph tag. So if we transform the markup a little bit to something like this, now the introduction is within an h1 tag saying that it's a page header, and we have the story in the paragraph tag. Even this slight change makes a significant difference in terms of how a search engine sees the page. Instead of the introduction hiding anonymously in a simple p element, a computer can tell that the h1 element is a title on the page. And not just any title, but the first title. And in this context, it means the primary title and the most important one. Search engines use all kinds of different criteria to determine what shows up in the rankings. And again, I'm not even remotely touching on those concepts. All I want to express to you right now is that the type of tag you wrap your content in makes a big difference on how search engines see your page. So, content in an h1 element is more important to a search engine than content in an h2 element because h1 is the primary title of the page. Just like the content in the main element is treated differently like the content in an aside element, the main element signals to the search engine this content is important, while what's inside an aside is extra content that isn't the core of the message of a page. So writing semantic markup means that you're familiar with the purpose of the tags that you use for each element on the page. And if you remember that reference I showed you just a little bit ago, the meaning and purpose of each element is well documented. Now the best way to learn these nuances is to spend time becoming acquainted with the elements and find out what sort of content they're most appropriate for. Yeah, there's a lot there, and you don't have to know all the tags and the attributes just to get started. We're going to take it slow and just do one element at a time. So now I want to talk about one more topic before we move on to the next module, and that's how you know the HTML you write is correct. So, markup validation is next.

Validation
Now, as you write HTML, one of the things that you want to know is whether or not the code that you create is valid. So if we return back to our simple web page and take a look at the underlying HTML, we can take the markup for this page and give it to a validation service, and they'll let us know whether or not we're following the rules of HTML correctly. So here I'll copy the code and take it over to validator.w3.org. The W3C is an organization that's responsible for directing HTML, and here they make a validation service available to you so you can check your code. Now there's a couple different methods you can use. You can give it a URL, you can upload a file, but we'll use the direct input method. Here I can paste in my code from my page and click on Check. And as we scroll down to the results, you can see that the validator returns back some feedback about the code for the page. So here you'll notice that I'm missing the language attribute for my HTML element and that it's also looking for a doctype element at the very start of the page. So as you write more and more HTML and you're looking to see if you're following the rules correctly, you can go over to validator.w3.org and find out. Now that you've seen how to validate your code, let's look at the different pieces, the different building blocks of a web page, and find out the difference between HTML, styling with CSS, and logic with JavaScript.

Anatomy a Website
When you look into the browser, you see a web page that's made up of text, and images, and video, and a number of different interactive elements. And when you see all those pieces put together in a refined way, you're seeing the final product of a series of different technologies that are put together in just the right way to present to you what's called the user interface. Now that user interface is a web page that's put together through HTML, what's called a style sheet, and a scripting language called JavaScript. Let's break these down by thinking about the different aspects of how it relates to a person. When you see a person often, one of the first things that you notice about them is their physical appearance. That physical appearance is how you interact with people on a daily basis. And people look a lot different depending on their bone structure and the clothes they decide to wear each day. So if we were to equate a person's skeletal system to the structure that's found within their body, that's the same thing as HTML within a web page. As you create markup around content, you're creating a structure for the page. Now by itself, like you saw in our original example, really isn't much to look at. It's just pieces of information that are thrown on the page, and so you need another layer of technology that's responsible for what we call the style. So when you think of style or, in our example, a person's clothes, that's made possible through Cascading Style Sheets. So HTML provides the structure, Cascading Style Sheets provide the style, or the look and the feel, and lastly, no person is complete without what truly makes them unique, and that's their brain. The brain is where a person's thought, and logic, and reasoning happens. And while our web pages aren't quite that advanced, the brain represents the programming, and the business rules, and the logic that we build in to our web applications. And this is handled through JavaScript. So when HTML gives you structure, CSS gives you style, and JavaScript brings you interactivity, together, you have a fully functioning website. So now with this context, in the next module, we'll start looking at Cascading Style Sheets and how you can add style to your websites.

Up Next
So now that you're a little more familiar with what HTML is and its purpose, next, we'll look at adding style with Cascading Style Sheets in order to make that raw HTML look just a little bit better. Beyond just looks, we'll explore how different types of style sheet rules are applied to different devices in order to create a website that responds differently to desktop browsers as it does to mobile devices.

Adding Style with Cascading Style Sheets (CSS)
Introduction
Well, welcome back, and thanks for joining me for adding style with Cascading Style Sheets. Cascading Style Sheets is the technology that you use in order to add different fonts, change colors, change the size of elements on the page, create layouts, and so much more. In this module, you'll learn about some of the styling basics. We'll cover what style rules are, where to place them, how cascading works, and you'll begin to learn about selectors. So let's go ahead and get started by opening up the browser and start experimenting with some style rules.

Style Rules
Cascading Style Sheets work by allowing you to define rules that describe how you want your elements to appear on the page. Now you can add these style rules in a couple different places, and I'll cover the different locations in a bit. But for now, you can take the simple markup and add to the head element. And I'll also add an element on the page to style. The div element stands for division, and we'll end up using these a lot as we build pages. And now I can use this tag name to change how it looks in the browser. Up in the style section, I can target my rules to this element by adding the tag name for div and then the open and close curly braces. Now I can change the background color and even the text color. Notice how each style rule is formatted with a style property name, a colon, and then the value. This is the form that you use to create style sheets. Now you'll see me use these color codes a lot throughout the course. The CSS color rules accept color information in a few different formats. Here I'm using what's called hex code, and I've just memorized these values. But don't worry, you don't have to. In fact, if you type any color in and then hover over that color, Visual Studio Code opens up a color picker where you can select any color that you want. So style rules are made up of a selector, they're contained by curly braces, and then you have the rule, colon, and then value. So now let's talk about what's built into the name of CSS and discuss the cascading nature of style sheets.

Cascading Rules
As the name Cascading Style Sheets, or CSS, suggests, there's a number of different cascading rules that come into play as you build your styles. So in this section, we'll look at the different rules and how they affect the way your web page looks. So we'll begin again with some very simple markup, and I'll add to this page an h1 element, or the page's title. Now the first thing that I like to do is change the color of the title, so I can go up into my style rules, and I can create a selector for my h1. Now, with this selector in place, I can go ahead and add a style rule. Let's change the color to a bright blue. So as the browser encounters this page, it interprets the styles and knows that any h1 that it encounters, it will style it with this color of text. The color rule applies to the text within an element. Now, what would happen though if I created another rule right underneath it? So again, this is for an h1, and this time we set the color to a light gray. Now, when I press Save, what's going to happen? Is the text going to be blue or gray? Well, it turns out that it's gray. Because of the cascading nature of style sheets, whatever rule the browser encounters last as it adheres to the cascading precedents will win. So in this example, whatever selector comes last has the rule that wins. Next, we'll look at what's called rule specificity.

Specificity
Beginning again with our simple page, here we just have the h1 Title, but this time I'm going to add a class to the element. So here I'll say, class="heading". And now within my style sheet, I can create a class‑based rule that says the heading will show up as a different color. So now when I save the file, the browser will read the style rule, and the Title is colored as blue. Now the reason that this shows up as blue is because I've told the browser to color any element, whether it's an h1 or anything else that has the class of heading, color that element with the color of blue. Now, if I come down here and create another rule and tell it that I want to style each one of the h1s as gray, what will happen? So, do you think that the class rule or the element rule will win? Well, let me press Save, and we'll find out. So nothing changed. The reason the text is still blue, even though the heading rule comes first and the h1 rule comes after, is because the heading rule is more specific. The class attribute is considered more specific on an element than its tag. Another way to think of it is that an element has its tag, and the tag name generally describes what it is and what its purpose is. But as you add values with into the class, you're giving more and more specific information about what that element is, so a class rule will win out over an element rule. Next up, we'll look at how rules inherit from one another.

Inheritance
Now, some style properties are inherited, and some aren't, and there's no real guideline that you can follow that helps you know exactly which ones are and which ones aren't. You kind of just have to become familiar with the style rules to know how they work. But let me give you an example of how inheritance works. So here on my page, I have my body and my h1 Title. So what I can do is go into my style sheet and tell the body that I want to give that a background. We'll give it a light gray background. The style property that we use for the background is background‑color. And when I press Save, you can see that the page takes on a background color. Now you notice the Title element, and if I inspect element over here and hover over this item, you can see that the Title element also has a gray background. But I can create a new rule to override that inherited value. So now for the h1, I can make the background color white, and now my page has a gray background and my Title element has a white background. So the h1 inherits the background color of the parent until a lower‑level style is defined. Now, like I said, not all properties inherit. For instance, a dimensional property like width Let's take a look at that in action. Here I've updated the page to have a main element inside body, and inside that I have a div with the text Hello. So let's start off by making the background color of the body a light gray. When I press Save, you can see that body now has that light gray background. Now for my main element, we'll change the background‑color and give it a width of 50%. So now the main element has a different color gray background, and it's set to take up only 50% of the width of the page. Now let's add a background color to the div. So before I press Save here and you'll be able to see the dimensions of the div that's inside the main element, do you think it'll take up the same amount of space? In other words, turn the darker gray bar in to white? Or do you think it'll only take up 50% of that space? Well, since width is not inherited, the div is in fact taking up 100% of its container, which is the main element. So if I wanted the div to be only 50% of its container, I would have to give it its own width property. And so when I do that, now you can see each level of the structure of our page. So inheritance is a very powerful concept found in Cascading Style Sheets. Many of the styles that you work with are inherited from the parent, and this is exactly what you want because this saves you from having to restate rules over and over again that you set higher up in the chain. All right, next up, I'll show you how the location of your style rules can affect how they're applied to your page.

Location
Now there's a number of different options that you have available to you in order to place your style sheet rules. And interestingly enough, the placement that you choose affects how they're applied as well. One of the attributes that's available to us of an element is an attribute called style. Within the style attribute, we can add style sheet rules directly to an element. So if I wanted to make my title blue, I can do that using the style attribute. So now when I press Save, the browser updates, and I have a blue title. This technique, however, is frowned upon because you lose a lot of flexibility by adding styles directly to an element. There might be some cases from time to time where you'll want to do this, but more often than not, what you'll want to do is apply your style rules through a style sheet, and that's what you've seen in the examples so far. So I'll take this style rule, and I'll put it up into a style sheet, or essentially, within the style element. So as I remove it from the style attribute, I can come up into my style, create a selector for the h1, and add my rule in there. When I press Save, you'll see that nothing changes because, essentially, I'm taking the same rule and applying it to the h1 element, but now the instructions show up in the style element. Now, having styles directly in your page, again, comes at the cost of a little bit of flexibility. Sometimes, in fact, oftentimes what we'd like to do is take our style sheet rules and place them in a separate file. This becomes important because as browsers cache files, you can load a style sheet file into your browser one time, and then each page in the website can reference that, making your website faster. There are many other really compelling reasons to put your styles within an external style sheet, like maintenance and the like, so let me show you how to do that. Here I'll take this style rule and the selector and copy it out of the style element. And now what I'll do is create a style sheet file, and that's a file with the extension of .css. So here I've created a file called styles.css. I can take my rule and place that into the file. Now, if you look over at the browser, you can see that the text has turned black again. And this is because within my HTML file, there's no reference to my style rule. So let's go ahead and add that. Underneath head, I'll add a link element. Now Emmet is here to help me out, and it automatically creates an attribute of rel="stylesheet". And now, in the href attribute, I can point to my style sheet. And now when I press Save, my browser is referencing the style sheet, the rule is introduced back into the page, and the Title turns blue again. Here, I'll expand out Visual Studio Code so you can see that full line for yourself. Now what's interesting is what happens when you begin to mix and match styles that are found within different placements. So right now I have a style sheet that says my Title is colored blue, but what happens if I bring that style back and add a different color here within my style element? What if I wanted my Title to be pink instead? So with my hex code of fcc, now I've made my Title pink. Now remember, we're dealing with the exact same element, selector, and rule. The only difference is that the blue rule is found within the style sheet file, and the pink rule is found here within the style element. Well, if I go down to my style attribute and add yet another color, let's see what happens then. So here I can add in a code for a dark red, and what do you think will happen when I press Save? Well, that's right. The style attribute wins because it's more specific in scope than the rest of the rules. So hopefully by now you're beginning to see how style sheet rules cascade down from the general to the specific through rules and placement on the page. Next, we'll look at selectors, and you can see just how much power is available to you in order to zero in on specific parts of a web page.

Introduction to Selectors
Selectors are a way to locate elements on the page, and for CSS, that's how it knows which elements to apply the style rules to. Now there's a number of different types of selectors. There's tags, class, ID, and attribute selectors, and so let me take you through how to use each one. Starting off with an HTML file that looks like this, we have an h1 title on the page, some paragraph text, and then two divs. If you remember, div stands for division, so this creates a logical container for a subheading and an image and a label inside a paragraph tag for each one of our divs. Now notice here each one has a class set as tutorial. So that means each one of these elements can be located and identified through the tutorial class. But each element has its own unique ID. You'll notice that the ID attribute here is different for each one of the containers. So the first one is tutorial‑1, and the second one is tutorial‑2. All right, now with this structure in place, let's start writing some CSS so you can see how different selectors can target different parts of the page. Here I've adjusted the window size a little bit, so you can see VS Code right next to the browser as we type in our style rules. So now, with all this set up, we'll start looking at applying a style using a tag selector.

Tag Selectors
So if you recall from our earlier discussion, an elements tag is the name of the element. So I'm going to create a style rule that targets the images on the page. Now you've seen these type of selectors before. We've used them often. Here what this is saying is that any style rule that I add within these brackets will be applied to any image on the page. So here I can set a border. I'll create a solid border of 1 pixel and make it a gray color. When I click Save, each one of the images on the page gets that gray border. Now, since this is a tag selector, any element tag that I put in the style rules will match against the corresponding element and apply those styles to any one of the elements on the page. All right, well, this is great for making widespread style rules, but what if we only want to target certain parts of the page? Well, let's take a look at class rules next.

Class Selectors
Now, if we review the structure of the page again, you'll notice that I have two elements on the page that each have a class attribute with the value of tutorial for each one of my div elements. So now what I want to do is write a CSS rule that can target each one of these elements. To do that, I start off with a selector that begins with a dot or period. That dot or period tells the browser that it's looking for elements based upon the class name. So here I I can type .tutorial and open up a rule block. Now I can give my elements a border. And when I save the file, the browser updates, creating a border around each one of the elements. Now what's valuable about class selectors is that you can apply the same class name, or essentially a label, to multiple elements. So I could have a number of different divs on the page, some of them might be for tutorials, and some of them may be another type, but by applying the tutorial class to just the right elements, now when I want to create a style only for my tutorial divs, I can do that easily with a class selector. Now, what if we want to target elements specifically by name? Well, to do that, we'll use an id selector, and we'll look at that next.

ID Selectors
Now, on my page, I have two elements that are containers for both of my tutorials. They each have a class of tutorial applied to them, but they also have distinct IDs. You use the id attribute when you want to uniquely identify an element on the page. Often, you'll do that with elements that collect data from the user, or you might use them for containers that include distinct information on the page. So here I want to write a style rule that only applies to my div that has the ID of tutorial‑1. Now, to create that selector, instead of starting with a period like I did with the class, I'm going to start with the pound sign, or the hash symbol. So this rule only matches the element that has the ID of tutorial‑1, and go ahead and give it a background color. So now when I save my changes, the web page is updated in order to create the background color just for that one element. Now most of your selectors will be a combination of class, ID, and tag selectors, but there is even more power available in different selector types, so next, we'll look at using an attribute selector.

Attribute Selectors
Now thinking back to our previous conversation about different aspects of an element, if you recall, there's the image tag, there's an attribute, and an attribute's value. Now, we can use these different parts of an element in a selector, in order to create a style rule that can be very specific or very flexible. Now, if you notice, I have an img element on the page here that has a src value the equals https://via.placeholder.com/150. And this is a location for a placeholder image, as you've seen on the browser, that makes it easy to create sample web pages. Now, what I'd like to do is create a style rule that targets this element on the page based off of that source value. So in order to do that, I'll start off making a selector that begins with a tag name. And then to tell it that I'm targeting an attribute value, I'll use the open and close brackets. These brackets tell the browser that the selector is looking at an image with a given attribute value. So inside those brackets I can tell it what attribute we're looking for, and then you put the desired value inside the quotes. So I'll just copy the image location down from the page, and I'll paste it into the selector. And from there, I can add in a rule. So here I'll give the image of border. This time I'll make it 3 pixels, and I'll make it blue. So I'll adjust the size of VS Code so you can see the browser again. And now when I press Save, just that image on the page is updated with the colored border. And the way that it's finding that image is because it's looking for an element on the page that has the tag of image, but not just any image element. It has to be an image element that has a source attribute with the value of this placeholder location. So attribute selectors can give you a lot of power when it comes to selecting elements on the page. Now, so far, we've only looked at selecting one thing at a time, either one class, one ID, one tag. Let's take a look next at how you can select more than one element at a time.

Selector Lists
So far, up until this point, I've shown you how to use selectors one at a time, so either a class selector, a tag selector, or even an attribute selector. Sometimes what you'll want to do is target more than one element on the page in order to apply the same style. So to do that, you'll use a list selector. So for instance, let's say I want all the titles on my page to be the same color. Well, I can do that with a list selector. So here I'll create a list by adding a comma between the h1 and h2 headings on the page, and then I'll give them the same color. So now, as you can see, the h1 and the h2s on the page all have the same text color. Now I can mix and match the different types of selectors as well. So let's say I want to use a class selector with a tag selector. I can absolutely do that. Here I'll use the tutorial class selector, and let's say I want to give that and the h1 on the page a border. Now when I press Save, you can see that the header and each one of the tutorial containers now have a border. So list styles are really powerful because they give you the opportunity to apply the same styles to multiple different elements on the page. All right, next, let's look at the way that you can target children elements and add styles specifically for them.

Combinators
Now one form that your rules can take on is a child combinator rule, and that's a big fancy term that basically says you can create a rule that targets a specific child of a specific element. So if I wanted to select the paragraphs, but only the ones that are found inside of elements that are marked with the tutorial class, so it would be these paragraph elements here, I can do that with a child combinator. So going back up to my styles, I'll start off by targeting the tutorial class. And then I'll use the greater than sign, which essentially creates an arrow. So I'm saying tutorial, and I have my arrow pointing at the element that's inside the element that I selected, so here I'll say all the paragraph tags inside the elements that have a class of tutorial. And to do that, I'll increase the font size, and now when I save the changes, you can see that the font size is increased for the paragraphs that are inside an element that has the tutorial class. Now you even get hints of these types of selectors being used in all kinds of different places. In fact, if you look up at the top of the window here in VS Code, you can see it uses that same type of selector syntax to show the parent‑child relationship between different elements within the page. Now there's lots of different variations and a number of other different combinators available to you, but for now we'll move on to showing you how you can use the browser to help you build styles in real time.

Display Property
Now there's a concept within web layouts that I want you to be aware of that affects your style rules. So here I have a div on the page that just renders out Hello World. By default, the div element is considered a block‑level element. What that means is that if I inspect this element and I hover over it, you'll notice that as I'm selecting just the div element, it highlights the entire space across the browser window. So it takes up a full block of space as it's being rendered within the browser. Now there is another option available, and that's display: inline. Now what's interesting here is you'll notice that the box around Hello World collapsed a little bit because our width property is now being ignored by the browser. You can see how inline elements work a little bit better if I separate out this markup a bit. So now with two divs being styled as inline elements, they render next to each other in line. And if I inspect these elements, since they're set to display as inline, they only take up the space that they need to be rendered there within the browser. But we have a problem because sometimes what we want to do is have an element appear in line, but also have control over properties like width and height. Well, what we can do is we can change the style rule to read inline‑block. Now we get the best of both worlds. We have elements that is played inline, stacked next to each other, but we still have control over style properties that are normally associated with block‑level elements like width and height. And having the understanding between the difference of block‑level elements, inline elements, and inline block elements will really come in handy as you build layouts for your websites.

Validation
Validating CSS rules is just as easy as it was to validate HTML markup. By going to cssvalidator.org, you can validate your style sheets by providing a URL to a style sheet, uploading your own file, or by direct input. So I just pasted in some style rules and then we can click on Check, and you'll notice that we have an error. It looks like I added in the wrong value for display and put block‑inline, instead of inline‑block. Now I can make that change. And once everything is just as it needs to be, your styles will validate and the website reports back to you that no errors are found.

Building Styles in Real Time
The browser is truly an amazing piece of software. Of course, it displays web applications, and it's our portal to the internet. And on top of that, the developer tools have so much to offer when it comes to developing websites. So here again, we've started off with just a very simple stub of an HTML page. Now I'll come down into the body and just create a single div element, and we'll add some text in there, and we'll just say Hello. Now when I press Save, we can see our element show up on the page. Now so far, we've dealt with styles that I've pre‑prepared for you. But I want you to think about what sort of process you might go through if you wanted to add some style to this page. How would you know what selectors to use? How would you know, really what the colors would look like until you wrote those rules into your page, saved the changes, and brought them up into the browser? Well, when you want to work in kind of an experimental way, there's a much easier way to do that than going through the process of thinking up a rule, saving the file, and looking at it in the browser. And so now I'll right‑click on the element and choose Inspect. Now it's a little hard to see, so I'll expand out the browser here for a moment. And with the Elements tab selected, you can see that we have the HTML that's generated and served up in the browser. And then over here, you could see that we have a listing of styles. And in fact, if I expand this out, what I can do is come into this window and begin adding styles and watch how it's applied to the elements in real time. So here I'll start off by adding a border, and then we'll add some padding around it to take the content away from that border a little bit. I'll change the background color to another gray. I'll set the width to 40px. Now we can align the text inside this box and center it. Let's go ahead and change the font as well. Here, I can add in a list. I'll say Arial, Helvetica, and sans‑serif, clean fonts that are found in most of the browsers around the world. And now what I can do is I can change how the cursor looks when you hover over it. So right now you see it creates that I‑beam type of cursor. Let's change that to be a pointer. And now, essentially, what we've done is created a button out of just a blank plain div element. Now here, in this view, I can come into these checkboxes and check and uncheck in order to apply or disable any one of these rules. So by using this window, it makes it really easy for you to be able to add style rules and immediately see what they'll look like on the page. But there's only one problem here. If I refresh the page, we lose all these styles, and we don't want that to happen. So now what I can do is just select these styles, copy them, and now when we come back over to VS Code, I can create a new style called button, paste in those rules, and now apply that class name to my div. And now any element that has that class name gets that style, and that style was really easy to create because I could do it in real time in the browser.

Up Next
Well, congratulations! You've now seen how you can add styles to your web pages using Cascading Style Sheets. So now, in the next module, I'll show you how to work with Cascading Style Sheets a little more in depth. We'll talk about building layouts, determining browser support, and how you can validate the code that you write for your CSS rules. And the best part is when we're done looking at layouts, we'll return to Bethany's Pie Shop and begin building her very first pages.

Working with Cascading Style Sheets (CSS)
Introduction
Now that you've learned how to add styles with Cascading style Sheets, let's look at working with them more in depth in your web pages. In this module, you'll learn about the box model, how to create layouts for your web pages, how to target desktop versus mobile devices, how to determine browser support for the styles that you write, and how to validate the CSS code that's a part of your website. So let's begin by talking about the box model.

The Box Model
Every element in your web page has a sense of presence on the page. The way the browser interprets this presence is called the box model. So, let's take a look. So we'll start off with a very basic web page that has some very simple styles applied to a div element. So, down on line 17, you can see I have a div that has the text Hello in it. I've applied a couple different style rules to this element, so we have our box in the middle of the screen that says the text Hello. Now, in order to make it look like this box, we've given it a background color, set the margin, border, padding, width, and height, all in order to make this element look like a box. But let's open up the developer tools and take a look at a utility that better depicts how the browser sees this element within the page. So I'll right‑click and choose Inspect, and then I'll make our browser a little bit bigger for us to work with here. So as we take a look at the Elements tab, bring your attention to the bottom right corner, where you can see a representation of how the browser sees this element. So for each element, we have margin, border, padding, and then the dimensions. Now these dimensions are a little bit bigger than what we created for our box, and that's because it's looking at the body element of the entire web page. So I'll use this selector and click on the box itself, and now when we take a look at it, you can see that the values that we added into the style correspond to the diagram that we see below. So the margin value that we created was for 25 pixels. Now the margin is the space between the border itself and everything else around the boundary of that element. As depicted here, the border was set to 1 pixel, so there's a nice thin border around the element, and padding is the space inside the element, in between the border and the content of the element. And then lastly, we have the height and the width of the element itself. Now, there's something interesting that you need to notice here. Now while I set the width for this element at 100 pixels, the actual width for this element is 202 pixels wide. That's 25 pixels on both sides for the margin, 1 pixel on both sides for the border, and 25 pixels on both sides for the padding, and then 100 pixels for the width of the element inside the box. So as you're styling elements on the page, it's important for you to know how the margin, border, and padding values affect the dimensions of the elements on your page. Okay, now that you're acquainted with the box model, let's take a look at the type of style rules you'd need to write in order to create columns on your page. And remember, every step of the way is getting us closer towards creating that layout for Bethany's Pie Shop.

Columns with Float
Now one of the fundamental features of creating a layout for a web page is to be able to create columns, and unfortunately, that is a lot easier said than done when it comes to building a web page. So the first thing I'd like to do is show you a common way that people try to achieve a column layout, and I'd like to highlight a few of its problems, so then next I can show you a little more of a robust solution. But by taking a look at this basic example, it helps you understand the value of some of the other approaches. So starting off here, we have a very basic, simple HTML page. I have a div on the page, and it has a class name of columns. And we'll use this class name in order to add style to the elements that are inside of it. So to start off, let's create a class for columns itself. Now this is a container class, so the first thing that I want to do is give it a width of 100%. And I'll put a border on there as well so you can see how much space it's taking up within the browser. So when I press Save, you can see now I have the columns container taking up 100% of the width of its parent container, and it's got that border. All right, now let's see if we can get Column 1 and Column 2 to situate next to each other. For my next style rule, I'll use a child selector. So what I want to do is target all of the div elements that are a child of my columns class selector. Now when you think about creating columns, essentially, what I'd like to do is take each one of these div elements and make them take up the same amount of space on the page and then situate them next to each other. So I'll give each one of these divs a width of 50%. Now, just so that we have a better idea of what's going on, let's add a border around these elements. So now you can see each one of the divs is set to take up half of the amount of space of its container. So now we just need to tell Column 2 to float up next to Column 1, and so we'll use the float rule for that. We'll say float: left;, and what this rule should do is tell the Column 2 div to show up next to Column 1. But because of how the box model is at play, and the width value and the border values are being calculated into the overall width of these elements, there's not enough space to create the columns when each one of the divs is set to be 50%. So if I come down here and make this 49%, now I have two columns that are floating right next to each other, but there's still a problem. I have this space left over at the edge of the page. And when you begin designing layouts, small bits of extra space can be really frustrating. So instead of using the float rule, let's take a look at how Flexbox can help make our life so much easier.

Columns with Flexbox
Starting off in the same spot as we did when we first tried to create columns for a layout, here we'll use Flexbox, and we have our columns class and our divs for Column 1 and Column 2 available on the page. So let's start off by creating a selector for the columns class and giving it a border. So here we have a border applied to the container. It takes up 100% of the width of its parent, and so with this we can start creating some columns. Now, I'd like to introduce you to display: flex. By adding this one rule to our page, now when I save the file, you can see, well, we've got two columns on the page. Now, this isn't quite the type of layout that we want, so let's customize this a little bit more. We'll start off by creating another child selector in order to target the divs inside the container. Now, just to show you how powerful the Flexbox is, let's go ahead and start off by adding our borders in for each column, and you'll see how that doesn't get in the way this time. And now in order to give the dimensions that we want to each one of the columns, we'll add in the flex rule. Now, by saying flex equals 1, I'm telling the browser to evenly distribute all the space that's available within the container and allow each one of my divs to take up one portion of that amount of space. So, essentially, since I have two columns, by setting flex equal to 1, I'm telling the browser, allow each div to take up one column's worth of space within the container. Now, to illustrate this a little more clearly, let's see what happens when we add a third column into the mix. So now, simply by adding a new div onto the page, we have three columns that are equal widths, but I have even more control available to me with Flexbox than that. Let's say for our layout we want Column 1 and Column 3 to be more narrow, and Column 2 to take up a majority of the space within the page. Well, we can do that by adding in another selector. So here I'll start off with another child selector based off the columns container. Now I'll create another child selector, and then I'll use a very special type of selector called a pseudo‑class. Now the syntax for this is to add a colon, and here VS Code is giving us a number of different options available for pseudo‑classes. So I can target the first‑child of the container, or the first of a specific type. What I'm looking for is I want to make Column 2 a little bit wider than Column 1 and Column 3, so I'll use the nth‑of‑type pseudo‑class. Now by using nth‑of‑type, what I'm telling the browser to do is to look for a div within the container based off its position. So when I add in 2 here, it will skip the first div and select the second div. So now I can add a rule into this block and tell the style that I want the flex value to be 2. So, what will happen when I save the file? That's right. Column 2 is wider than Column 3 and Column 1. And so what Flexbox is doing is it's calculating all of the available space needed for the columns, giving Column 2 a double portion of that space, and Column 1 and Column 3 get a single proportion of the space allotted for the columns. Now there's so much more that you can do with Flexbox, this just scratches the surface, but the rules that you see here will get us where we need to go in order to build Bethany's Pie Shop. So next let's take a look at how we can target rules to only apply to the desktop or mobile devices.

Responsive Layouts: Viewport
Media queries allow you to target your CSS rules to different devices. This means you can create rules that target the desktop browser versus other rules that apply to mobile devices, so let's take a look and see how this works. So here, I have three divs on the page, one that will show up on the desktop, one for mobile devices, and even one that shows up only when you print the page. Now when you're designing for the web and creating styles that target different devices, often the best approach is to design for mobile devices first. This is important because it forces you to make sure that your layout works in the smaller dimensions before it works in the larger ones, so we're going to use that approach here. Now before we start writing CSS rules, there is a special metadata tag that you need to be aware of that's essential in order to make our styles work correctly, The metadata element with the name of viewport is required in order to let the device know how to interpret its width. So what this element is doing is telling the browser that the viewport or the way that the page is rendered within the browser will have a width of whatever the device width is. This is important so that the page is rendered at the correct width of the device. An initial scale is a setting for the scaling or the zoom. So by setting initial scale equal to 1, we're telling the device take on the 100% zoom setting, so you're not zoomed in and you're not zoomed out. Okay, well, with this in place, now we can write some CSS rules that target different devices.

Responsive Layouts: Media Queries
So now with the viewport defined, I can start working on my styles. Now I want to make sure that I'm doing my styles for my mobile devices first. So the first thing that I'll do here is make sure to hide the Desktop and Print elements. To do that, I'll create a list of class selectors and give it a style rule of display: none. Now when I press Save, you'll notice that those elements disappear from the page. With display: none, it tells the browser that any of these elements no longer take up any physical presence within the layout. So by setting display equal to none, I've essentially taken those elements out of any of the rendering on the page. So using display: none is a very common way of hiding elements on the page. Next, I'll create a media query just for when the page is printed. Now I'm showing you the print media query because other rules that we'll use target the screen only. So we start off with the at symbol (@) and use the media keyword. Then I tell it that this works for printing only. And so, within this media query, what I want to do is create the reverse rules for what I initially set up. So here what I want to do is tell the Mobile and Desktop elements to be hidden and then show the Print element. So this will hide the Mobile and Desktop elements. And by setting display to block for the Print element, that will show that element as we print the page. So when I press Save, you'll notice that nothing happened in the browser in and of itself. As it's rendered on the screen, it looks just like our mobile stylesheet. However, if I come over to the browser and type Ctrl+P, you can see within the print preview that the only thing that's rendered on the page to be printed is our Print element. Next, we can target the desktop browser on the screen by using a different media query. So here I'll build the rule with media screen and then add in a selector. Now I'm adding the 'and' keyword in here so that I can create a selector for the rules to be applied only in certain situations. So in this case, I only want to apply the rule where the width of the browser is greater than 768 px. So to do that, I'll use the min‑width property. And so now I can tell the Mobile elements to hide and show the Desktop ones. So, again, any screen that's 768 px in width or greater will hide the Mobile element and show the Desktop element. So let's save the page and see what happens. Well, nothing's happened. That's because of the screen resolution I'm recording this with. In order to show my screen side by side, the screen width is less than 768 px. So if I take my browser and I expand it out, you'll notice that after it crosses over that threshold, it begins to show the Desktop element. Now when you're testing media queries and you want to see what they look like in different environments, just changing the size of the browser is not the best way to go about it. And the browser developer tools once again make your life so much easier. So I can open them up by saying Inspect element, and then you'll notice there's this icon here where you can toggle the device toolbar. When I click on that, it creates a simulation of what this page might look like under different mobile contexts. So here I can come up here and select from a number of different preconfigured devices. I can change the orientation and even the zoom level. And so you'll notice on an iPad Pro, we'll get the Desktop experience because of its dimensions. But on an iPhone 5, it renders the Mobile experience. So media queries give you a lot of power in being able to target your layouts for different contexts. Well, next, let's look at how you can determine browser support for the CSS that you write.

Browser Support
Now, just like when you're writing HTML, you'll want to know about the browser support for the different CSS rules that you write for your websites. And to find out which rules work in which browsers, we can use the website caniuse.com. So let's take a look at one of those rules, and we'll take a look at Flexbox. And so through this table you can see that Flexbox enjoys quite a bit of support throughout most browsers available in the world today. Up in the top right‑hand corner we've got stats specifically for the United States, because that's where it detected I am at the moment, as well as global stats. And any feature with this type of support, you can safely use in just about any production application. Scrolling down the page a little bit, you have the opportunity to read some of the developer notes about the feature, and I find the Known Issues tab to be particularly enlightening. This is where you can really dive in to edge cases where certain features may have restrictions under special circumstances. So that's a well supported rule, let's take a look at something that's not quite as ubiquitous. (Typing) The hanging‑punctuation rule allows some punctuation characters from the start or end of text elements to be placed outside the box in order to preserve reading flow. Well, as you can see here, we have a whole lot of red, and this rule is not supported well enough for you to be able to use in a production application. So chances are most of the rules that you choose to use for your layouts are going to be supported well enough for you to not have to worry about it, but if you have any question, make your way over to caniuse.com and find out for sure. Now let's just take a few minutes and talk about how to validate the CSS for your site.

Up Next
Well in this module, you've learned about the box model, how to create layouts with columns, how to support multiple different devices, determine browser support, and even how to validate your style sheets. Now let's take all of the concepts that you've learned so far and start building the first content pages for Bethany's pie shop.

Building Content Pages
Introduction
Well, you have come a long way since we first introduced the very basics of HTML. We made our way through style sheets, and now we're ready to start building the website for Bethany's Pie Shop. In this module, we'll set the foundation of the HTML for the home page, develop the global style sheet, and styles specific for each of the content pages. All right, well, let's get started. Let's start building the home page.

Create the Foundation
So let's start off by returning back to the starter project that you downloaded and opened up earlier on in the course. Now just to review, this is the starter project for the application, and so we have empty files for each of the files in the website. We've got the index file, our order file, our list of pies, our contact file, and the global stylesheet file. Now, once again, we'll be using Live Server in order to watch the changes as we make them here in VS Code. So let's get this page started off right, and we'll use the Emmet shortcut in order to create the basis of an HTML file. So I can just type ht and then come down and select HTML:5. That will give us an HTML5 stub of a web page. And a lot of this should look familiar to you by now. So we have our doc type. We have our HTML element set with language ="en" for English. We know this will pass our validation rules. Here we have a meta tag. The character set is UTF‑8, which is the text encoding for this page. We have our viewport. That's already put in there for us, so when we create responsive styles, they'll work as expected. We've got a title and then our body element. So I'll save this, and then I'll right‑click on the page and say Open with Live Server. That opens the browser for us automatically. And when I come back over to VS Code, what I'll do now is hide the explorer. That gives us a bit more space. And now I'll shrink VS Code, so we can see both windows at the same time. So now when I type something in the file and save it, we can automatically see that change in the browser. Now, just to serve as a reminder of what we're building, this is the home page. So we'll start off by creating the navigation at the top of the page, add in an image for the logo, create the markup for the content of the page itself, and then add the markup for the footer. Once the structure is in place for the HTML, then we'll add the styles, and the final result will be this home page here for Bethany's Pie shop. So here I can add in the structure for the top navigation of the page. And we'll start off, of course, by using an Emmet shortcut again. So what I want to build is a header. Inside that, the site navigation. The element that we can use here is the nav element. Then I want to create an unordered list. And inside that list, I want to create three different list items. And inside each one of the list items, I would like to create an anchor for a link. So now when I press Tab, all of that HTML will be generated for me. Now, if you recall our discussion about semantic markup, what this is telling a search engine is that this section of the page is the header of the page. Inside of it, I have navigation, and the nav element is meant to be a container for links that apply just to this site. So we wouldn't put a link to, say, an outside website within the nav element. This is just navigation for our website alone. Then we can create an unordered list, and then the list items here. So we'll create the first link for the home page. Now, this is a little strange because we're creating the home page right now, but I put it on here just for consistency's sake as you go through the different pages in the website. By adding the slash value for href, this tells the browser to go to the very root of the website. In other words, if we had bethanyspieshop.com, that's where this link will go. Next, we want a link to the pies list page, and so we can add pies.html here, so when you click on it, it'll go to that page, and then we'll give it the label of Pies. And lastly, we have a link to the contact page. Now when I press save, you'll see that the result is pretty unimpressive visually, and that really highlights the value of stylesheets. And we'll get to implementing the styles soon, but for now, let's finish building the rest of the structure of the home page. So next we'll look at adding Bethany's logo to the page.

Add Main and Aside Elements
Okay, so we've got our page set up with a header in order to have links for navigation to the site. So now what we'll do is add in the main content of the page. In order to do that, we'll use an element called main. Now the overall structure of the page will give us a header for the page, the main content, and then a footer for the page. Now the reason I use the main element for this page is because that signals to a search engine that the content within this page inside this element is the primary content for the page. Sure, the header and the footer are important, but it's basically just links around the site. We'll probably have some branding information, maybe some contact information. But when it comes to the main purpose of this web page, what's found in the main element is what we most care about. Now inside the main element, I'll use two different tags. One is called aside, and one is called article. Now, if you think of a typical magazine article, the main content flow of the page is the article text, and sometimes you'll have pull quotes that show up over on the side. Well, that's the difference between the article element and the aside element, which I'll use here. The aside element is important and contextually relevant to the content on the page. But it's not the most important part. So here I'm using the aside with an image inside of it in order to show the logo on the page. Again, important, but not the main value of what's rendered on the page. Now this line will get a little long, so I'll expand out VS Code so you can see the whole thing. And then we'll bring it back when we go to look at the result. As you've seen in the past, the source attribute is where we put the path to point to the image, and in this case, it's images/logo.png. The alt attribute gives a hint to machines about what this image is about. So whether it's a search engine or a screen reader, the text that we add in here describes the image. So here I'll just put in Bethany's Pie Shop. And so now when I save the page, the logo shows up on the screen.

Add Article and Footer Elements
Next to the aside element, we'll add in the article element with a number of different supporting elements. If you recall from the finished product, inside the main element, we have a banner, a title, and some text with a link to our pies list page. So that's what we'll add in on the page now. Now rather than typing everything out character by character, I'll paste in the markup for this page, and then we'll discuss it. So we've got the article element, and I've got an image element that renders out the banner, the h1 element, that's the main title for the page. Again, for search engines, they're really going to key in on this h1 element. Then I've got a paragraph of text that welcomes people to the page. So it's a message from Bethany and a link over to the pies list page. Now we'll just use emit one more time to generate our footer, and then we'll have everything we need for the home page. So here we'll create a footer with a navigation element that includes a list of anchors. We want three list items, so that'll be li*3, and inside those list items we'll render some anchor tags. And again, rather than typing everything out, I'll just paste in the links. And so now when we take a look at the result in the browser, the content is really coming along. We've got our top navigation, our logo, the banner, welcome text, and the footer links on the page. So now we can move on towards adding the global styles for the website.

Global Styles: General and Body Rules
Okay, well, we're off to a good start. We have the foundation set for the home page. We have all the pieces that we need in order to start styling it with a global style sheet. Now what I mean by a global style sheet is that we'll create a style sheet that works for every single page. This is all of the base styles that every page needs in order to make it look like Bethany's Pie Shop. Now, individual pages will have their own set of styles that customize what they need for those pages. But we'll get started off by creating the base styles needed for our website. Now to do that, what we need to do is reference our style sheet file. If we go back over to the Explorer, if you recall, the site.css file is what I have prepared in order to place all these style rules. But what we need to do is go back over to index.html and make sure that we add a reference to this file so that all the styles that we enter into site.css end up getting loaded into the home page. So to do that, we'll add a new element into the head of the page, and we'll create a link to site.css. So that's link. We're going to have rel="stylesheet". The href will be site.css. And then we need to tell this element that it's reading CSS, so we'll add a type attribute, and the value is text/css. Now the type attribute is important because that's what tells the browser when it loads this file to read it as a CSS file. So now switching over to site.css just to test to see that everything works right, we can change the background color to pink. And while we're not going to keep this color, this does show us that the style sheet is loaded into the file correctly. Alright, so now let's start writing some real styles. The first thing that we want to do is reset the margin on all of the elements on the page. So some elements like title elements have a little bit of margin and maybe some padding built in as their default styles. In order to get our layout working correctly, what I'd like to do is reset every single element so that it has no margin at all. To do that, I'll use the * selector. This says every single element on the page will get the following rule. So now I can set margin equal to 0. When I press Save, you can see that a lot of the margins around these elements are compacted in. This is good because now we won't be fighting with any default values, and so elements will only get the margin that we set. Next, I want to add in some rules that will help make sure that it calculates the dimensions of the page correctly. So here I have a selector for HTML and the body. So essentially, this is the entire page within the browser. And here, I'm setting the height to 100%. Now, while this didn't visually make a change within the browser, this helps other styles to be able to calculate their position on the page correctly. Now let's add some styles just for the body itself. These rules will rely on inheritance in order to make sure all of the other elements on the page have the style rules that we'll enter in here. So here I'll change the font, and you'll notice that VS Code gives me some options that I can choose from. So here, we'll choose the Arial, Helvetica, sans‑serif option. And now I want the background color of the body to be a light gray. I'll press Save, and we can see the change made to the file. The styles are starting to take shape, so we'll continue on in the next clip.

Global Styles: P and Header Rules
Now you might be wondering, Why am I setting the background color to that gray? When we take a look at the finished product, you'll notice that the top navigation has its own background color. Within the body of the page, we have an image applied to the background that's repeated in order to give us that striped look. And then when we come down to the bottom of the page, the footer has the gray color. So by adding this rule at this point, the footer is able to just inherit the color of the body. Now we want to add a style for all of the paragraphs within our website to have its own custom margin. Now I'll scroll down on the page, and when I hit Save, you'll be able to see here within the paragraph how the margins will change. So the visual difference was slight. But the idea is that with this type of rule, the first value is the margin for the top of the element, the second value is the margin for the right of the element, the third value for the bottom, and the last value for the left. So, essentially, this adds top and bottom margins to each one of the paragraphs within our website. Next, we can add styles for our header so that our navigation begins to look the way we want it. The first rule I'll add in is display: block. The second is position: fixed. Now when I hit Save, notice what happens? The logo shows up underneath the links at the top, but because I have position as fixed, when I scroll the page, you'll notice that the navigation links stay in place. And that's exactly what we see on the finished product. As I scroll the page, the top navigation stays fixed into position at the top of the browser. And so we want to add in that position. So we'll add a top and left dimensions, the top rule telling the browser to fix that position at the very top of the browser window, as well as the very left‑most edge of the window. Now let's make it take up 100% of the width of the page, set its background color, and add a little bit of padding. Here we'll use the color code that's specific for the theme for her website and add in the padding. So now we have a fixed element at the top of the page that includes our links. The links aren't quite exactly like what we'd expect yet, but that's just the style for the header. So, next, let's look at how we can customize the links within the header of the page.

Global Styles: Nav Element
So we have the fixed header set up, so now let's add in the rules to make our navigation links look a whole lot better. First, I'll start with a selector that styles the links depending on the click state. So I'm looking for the navigation element on the page, any links underneath that, and right now I want to style what they look like after those links have been visited, as well as their default state. So to do that, the pseudo class is just link. We'll make the links white, and use a rule called text‑decoration, and set that to none. Now text‑decoration: none says that our links won't have any underlines underneath them. So now when I save the file, you can see that the links turn white, and they'll stay white whether or not we've clicked on them before or not, and, of course, the underlining has been taken away from the text. Next, let's deal with how this list renders on the page. So we'll look at the nav element and target the unordered list within that element. Now we'll tell the browser to display this list inline and 0 out all the padding around the list. Now when I save the page, you can see that the bullets have disappeared from our list, and there's no extra padding around the links. Now for our final style for the list, we can add in some rules that target the individual list items within that unordered list. For these, we want them to display as inline‑block, set the list‑style to none, and set the left and right margin. So the first value here is for the top, so we'll 0 that out, then we have the right value, the bottom value, and the left value. So what display: inline‑block tells the browser to do is to display our element inline, so that means it stacks the elements right next to each other, but we put it within a special mode of inline‑block, saying that you can still have control over things like width, margin, padding, where you don't normally have control over those aspects when you have a normal inline element. List‑style: none; tells the browser to not even interpret this item as a list item, and then our margin values just give a little bit of space between each link. So you might be wondering, why even use a list element at all when we're trying to style it to look like a series of links right next to each other? And that goes back to semantic markup. When a search engine looks at our web page, it'll see that there's a list of links within a navigation element and has a better job of interpreting the meaning of those links, rather than just having random anchors scattered around on the page. All right, well, in the next clip, let's look at building up the styles for the main content area of the page.

Global Styles: Main Element Rules
Now the styles for the main element are going to give us our background for the page and enforce some base dimensions for us. So here I'll add a tag selector for main and tell the browser to display this as a block‑level element. Now to add in a background image, we can use the background‑image rule. Now rather than just adding a string here, we need to use the URL modifier to tell the browser to interpret the path that we give it as a path to an image. So inside the parentheses, we can add in that path within quotes. So here we're looking for images/background.png. And now when I save the style sheet, you can see that that background image shows up all across the page because all the content that's inside the main element is filling up the page, and that background image is set automatically to repeat itself. So as this page grows and shrinks, the background image will take up the same amount of space as the main element. But let's not stop here. Let's go ahead and add some padding, and we'll do that to the top and the bottom of the element. Here I'll use explicit rules instead of the shortcut, which I showed you for the margin up on line 43. And, really, this is just to show you the different ways that you can write the style rules. So here for padding‑top, I can tell it that I want the padding to be 3em, and padding‑bottom, the same thing. These two rules are necessary because of the navigation that shows up at the top of the page, and at the bottom of the page, we want to be able to have the content push away from the boundary of the main element in order to give space for those navigation elements to show up correctly. And the last rule that we'll add in is min‑height set at 85%. This rule is necessary in order to make sure that the bottom navigation shows up at the bottom of the page. So now when I save the file, you can see that the elements readjusted a little bit on the page. We're not really able to see much of the difference at this point. Mostly, it's that background image that's being loaded in for us. But as we flush out the style sheet and test it under different dimensions, then you can see how these rules really are relevant.

Global Styles: Footer, Aside, and Article Rules
So as we scroll down on the page, you can see that our footer is looking a little squished within its container. So let's add a rule in order to give some padding around that container so that those links have some area to breathe. Here I'll add 15px of padding around the entire div element. There, that's much better. Now, for the content inside the middle of the page, for aside and article we'll give it a padding of 2em. So when I save the page, you can see that now there's more padding around the content within the page. Now, the em unit gives you a chance to create size based off the current font size. So instead of hard‑coding these to a certain number of pixels, if you zoom in or zoom out on the page, depending on how the fonts are rendered within that container, the em unit of measure takes that into an account. So, pixels are a fixed value and ems are a proportional value. Another way of saying that is the larger my fonts are within my page, the more padding there will be around it, and the smaller the fonts, the less padding there will be. And this is important in order to create flexible layouts because as the dimensions change within your page, you want certain portions of it to be able to reflect that. So if I come over to the browser and I zoom out, you can see that over on the left‑hand side, the same amount of padding remains no matter how large or small the fonts are. Now, we want our site logo to show up centered on the page, so we can add a style for that. So inside the aside element, we'll say text‑align: center. So I'll save the page, and you can see that now it's centered. Now, a couple of different things are going on here. Number one, it says text‑align, and I just centered an image, and that might seem a little strange, and it is. But if you want to center an image or text within a container, this is the rule that you use. What's nice about using this type of an approach, when the page is rendered for a mobile device, because of the way the elements stack together under a narrow layout, the aside element will take up the full width of the page. However, and let's take a look at the finished layout for a moment one more time, when the layout is rendered for the desktop dimensions, the aside element only takes up a portion of the page because of the grid layout that we will implement coming up soon. So this creates a lot of flexibility for you. So the layout looks good under mobile contexts, as well as desktop contexts. But for now, the logo is just centered on the page, and that works great when we're working with really narrow viewports, like mobile devices. Now let's add one more style rule for our article, and that's to set the width of that element to 75%. Now, this rule makes sure that our content doesn't stretch too far across the page. And if you remember, we're doing mobile styles first. So all the styles that we've done up into this point are created in order to be optimized for our mobile layout. So in the next clip, we'll look at adding a media query and adding in some rules that help customize the layout specifically for desktop environments.

Global Styles: Media Query
Now our Home page is coming along quite nicely, and we've been able to style everything on the Home page so far using global styles. What I mean by that is all of the style rules that we've added into the site.css file will apply to every page on our website. So up into this point, all the styles have been tailored in order to be optimized for the mobile environment, so now let's add a media query that gives us a place to put in some rules for styles that target the desktop experience. So the media query that we'll use will give a minimum width, and target it to the screen. (Typing) So this media query targets the min‑width of 768px, so that means that these styles will only be applied to screen sizes that are 768px wider and above. Now I've gone ahead and just expanded out Visual Studio Code, because you won't be able to see the effect of these styles until we take a look at the browser in the full‑screen mode, so we'll add in the styles and then I'll show you the difference. So the first thing we want to do is for the main element to display as flex. Now the reason for this is because we're going to create a two‑column layout, and if you remember from our discussion on layouts and columns, display: flex makes creating those layouts very simple. So on the desktop, the main element will display as flex. Next, we want the logo to pull away from the left side of the screen just a little bit. So I'm going to add some margin to our aside element, and we'll give it a margin‑left of 2% of the total space available to the browser window. So we'll save those changes, and then we'll look at the browser in a desktop view. So there it is, now our desktop layout has a two‑column layout, and that logo is positioned exactly where we want it on the page for these dimensions. Now we're almost there. All we have to do now is add some page‑specific styles in order to make the Home page look exactly the way we want it. So, again, everything we've done up to this point are styles that apply to every page within the website. Now we'll add some styles that are only for the Home page, and so we'll do that coming up next.

Home Page Styles
So here we are, back in the markup file, the HTML file for the Home page, and we're going to add some page‑specific styles here. We could do that in a style sheet that's referenced out from the page, or we can do it inside a style element. Just to keep things simple, I'm going to use a style element here, but if you were building things for the real world, you'd probably want to use a separate style sheet. Now I noticed we don't have the correct title on this page, so let's go ahead and fix this up and title this Home page Bethany's Pie Shop. Now that we've got that squared away, let's create a style element and add some page‑specific styles. Now one of the first things that we want to do is update the style of the welcome text. We really need this text to be bigger and maybe change the margin a little bit. So we'll target the h1 on the page and tell it we want the font size of 3em, and what we'll do is add some margin to the top of 0.5em. So this makes the text bigger and also pulls the text away from the image just a little bit. Saving the file, you can see that now we have a proper welcome message. Now this banner is a little bit of a problem because you'll notice that it pushes off and seems to mess up the layout. Now we can fix that by telling the banner we only want it to have a max width of 100%. So we'll target the banner. If you remember down in the markup, we gave it a class name of banner. So now in my style, target that element by creating a style selector and creating the rule that says, I want the max‑width for this element to be 100% of its container. Now when I save the style sheet, you'll notice that it brings that banner down into size. And, in fact, if I resize the browser, you can see how it scales. So that's the value of creating styles with relative values or percentage values because they're able to adapt or, as we say it, respond to the different layout needs. These are the techniques that you use in order to begin to create a responsive website. All right, one more. The text down at the bottom of the page does not look good. What we want to do is have it pop on the page a little bit, so we'll add a background color, change the font size, and adjust the padding just a little bit. Again, there's a class name that we've created called sub‑title, and I'll use a class selector in order to create my rule here. We'll make the background color white. So we'll bump up the font size, give it a background color, and give it some padding so the text isn't pushed right up to the edge of the container. And with that change, our Home page is done. So whether it's on the desktop or on a mobile device, our website is starting to take shape. With the Home page done, we can now turn our attention over to the Contact page, and we'll do that next.

Contact Page
As we turn our attention to building the contact page, what we'll do is use the home page as a starting point. So here on index.html, I'll select the entire contents of the page, copy it, and come over to the contact page and paste all of the code from the home page. So that gives me the foundation of the page and gives me the building blocks of the layout. Really what I want to do is change out the content in the middle of the page, so essentially everything inside the article element. So I can delete the contents out of the article, delete the page‑specific styles out of the contact page, and then update the title. Oftentimes websites will put the title of the page first, and then a pipe, that's the vertical bar with spaces around it, and then after that the name of the website itself. This works well for search engines because then if the title shows up in the search results, you can see what page inside of what website is being returned. So I'll save all those changes, and then we can come over and click on the Contact page, and you can see that we've got the basis for the layout, just none of the content yet. So now we can go down to the article element and add in the content for the contact page. Now I've pasted in the markup here, and it's made up of an h1 that says it's the Contact page, a text message that's in a paragraph tag, and then this very long, interesting‑looking anchor. Now, before we talk about what that is, let's look at the page for a second. That anchor tag renders out a link that you can click on. And so when you do that, if you have a default mail client set up on your machine like I do, it'll bring up the mail program, it sets the To address to whatever you designate, and here for this demo it's example@bethanyspieshop.com, and then I also automatically added in some text for the subject for the email. So here, Interested in pies. So now that you see what it does, let me show you how it does it. The anchor tag is set up to have an href value, but instead of just pointing to a web address, it starts off by saying mailto. After that, you give the email address. After the email address, you put a question mark and then say subject=. Now this maps to the subject line in the email program, and then I can put in Interested in pies. But you'll notice I've got this special code in here, %20. That's a special type of code that tells the program to put a space inside the text. So here, Interested%20in%20pies. And so that code is what tells the email client how to construct the message. Then I can add in the rest of my label here, Send us an email, and then close the anchor tag. After that, all I have to do is put the rest of the message underneath it, and that's all enclosed in a paragraph tag, and that's what gives us the contact page. Well, now that we've got a way for people to get hold of us, let's build the pies list page so we can begin the foundation of starting to take orders.

Pies List: Markup
Again, using the finished product as our reference, from the Home page we can click on the Pies page and get a list of available pies. Now we're going to build this page in two different stages. First, I'll show you how to build the page in order just to display the pictures in this type of a layout, and then in the next module we'll begin talking about JavaScript, and after that discussion we'll add in the interactivity to this page. So this is where we're headed, now let's go back and start building this page from the ground up. So returning back to our Home page, we're going to take the same approach with the Pies list page as we did with the Contact page, and start by just copying what we have here to begin with. So on index.html, or my Home page, I'll select all, and then I'll copy this code and put it inside the pies.html page. I'll paste that in, and again, what we want to do is take out everything inside the article element, so I'll select all this code and delete it. Again, we'll get rid of the page‑specific styles for the Home page, and update the title to say Pies, and then add in that pipe. So when I save that, and now navigate over to Pies, you can see we've got the basis of the layout ready for us to put content into. Now, one of the first things that I want to do is create a new container inside the Pies list page. And so here I'll create a section element and give it a class of columns‑desktop, and we'll look at why that's important here in a moment. Now, the layout for our list page is going to be different on the desktop than it is for a mobile device, so by adding in this class, in the next clip we'll add some styles that will allow this page to work well on the desktop. So now we can add in two different pies. I'll add in the first one, which is an apple pie. Now each pie is going to take on a similar construction within HTML. First, there's a container div that has a class of pie. This is important, because as we add more pies to the page, by creating a class of pie I can add styles to that class name and it'll apply to each one of the pies on the page. Well, we need an image for it, so here's an image element for the thumbnail for our apple pie. Now, in this next container, I'm using the columns class. We're going to add the styles for this next, but this will allow the layout to position the price and the title next to each other in two columns. Then we have our description, and then the button we need so that we can place an order for the pie. So I'll save these changes, and let's take a look at it in the browser. And the result is pretty bad actually. It doesn't look good at all. And that's okay because we're going to fix that with the styles that we'll apply to the page in the next section. Well, let's go ahead and get our cherry pie in there, and then we can work on making this look better. So just like the apple pie, the cherry pie is within a container that has a class name of pie. There's the thumbnail image, the title, the price, its description, and then an order button. And one thing we didn't talk about a moment ago was this data‑order attribute. A data‑ attribute is a special type of attribute that you can add into an element that allows you to add extra information about that element. Now, when we go to create the interactive part of this page, in order to tell the order page what people have ordered, we'll ask this button for its value of the data‑order attribute. Now that's still to come, but at least you have an idea of why that's there on that element. So are you ready to take a look at what our page looks like now? Again, it's not quite what we want, but that's okay, because next we'll add in the styles that we need in order for this page to look the way that we want it.

Responsive Columns
So taking a look at the final product one more time, this is the pies list page, and this one looks pretty nice, but the current state without any styles does not look as great. But let's fix that by adding some global styles into the style sheet in order to create the look and feel that we want for these pies. Now it's going to go into the global style sheet because I have multiple pages that will end up rendering these pies on the page, and so we'll stick it in there so every page can reference it. Now, as we go to add these styles, we'll be using the pie class as a way to target the container and style the elements specifically for the pies on the page. And if you remember, the title and the price right now show stacked on top of each other, but we have them in a columns class, and so we're going to add some style first in order to make sure that these show up as columns. So when we switch back over to the style sheet, we're going to want to scroll down the style sheet to just before the media query. And so right here in this position, we'll add a style telling the browser to display columns as flex. Now when I save the style sheet, you can see that over here the title and the price stack next to each other instead of on top of one another. We'll add some more style rules in a moment to make it space out the way we want, but this is a good general style to have within the global style sheet. So any time we want to have columns, all we have to do is mark those elements as being columns, and they'll display as flex. Now, inside the media query, there's another style that we want to add that's specific to the desktop layout. If we go and look back at the HTML for a moment, inside the article we have first, the title, and also a section that includes the containers for both pies. But that section has a class of columns‑desktop. Now the purpose of that is so that we can show the pies stacked together in columns for a desktop layout, but they'll be stacked one on top of another for mobile layouts So let's add the style to tell the desktop layout to stack these as columns. And so inside the media query, we'll add a rule right underneath the aside rule, and this is for the .columns‑desktop class. And again, the rule here is display: flex;. Now I just saved the page, and of course, we don't see any change here on the browser because the width is so narrow. But if we take a look at it now with the dimensions for a desktop browser, things will change a little bit. So as you can see with that rule, now we have the columns stacking next to each other. So now in the next clip, we'll add in the rest of the styles in order to make these pies look exactly how they should.

Pies List: Styles
So now in order to start styling the containers for the pies, we'll add some rules just outside the media query rules. Now sometimes as your style sheets grow, you might want to add some comments in order to help you organize the styles better. So here I'll add a comment to signify that the following styles are just for the pies. Comments are lines of code that we can put in different programming languages that are completely ignored by the computer. So here the syntax for comment in CSS is /*, and then some text, and then */ to designate the end of a comment. Now the first thing that I want to do is style the container and give it an explicit width, some padding, some margin, a background color, and a border. So here I will start with a class selector, and give it width, padding, margin, background‑color, and this is the hex code for white, and a border, giving it the hex color for light‑gray. So now when I save the file, both of the pie containers have each of those properties. Now let's make the image inside the container take up 100% of the width available inside the container. So to do that, we can add a selector of pie and then img, and tell it to have a width of 100%. So the visual change here is slight, but the images now take up the maximum amount of horizontal space within the container, and it makes them consistent as well as far as the width is concerned. Now let's make the title bold, and notice how I'm prefixing each one of these style rules with pie, and then space, and another selector. What that does is that targets each one of these styles specifically to the pie container. So if I have a title in another part of the page, I may not want it styled the way I'm doing it here, and so by being careful about how I craft my selectors, I can make sure that my styles are only applied where I want them to be. Now, let's make the element that holds our columns take up the maximum amount of horizontal space so those columns spread out a little bit. So the visual change here wasn't anything you can detect, but once I add the next style rule, you'll be able to see why that width is important because now what I can do is I can tell the price to be aligned to the right, and then once we make sure each one of the columns only takes up 50% of the allowable space, now our pies are starting to take shape a little bit. So this last selector here looks for the pie container, looks for the container that holds both columns, and then styles the individual div elements to be a width of 50% each. All right, so then the last thing that we have to do is style the button. Here, instead of using a class selector, I'll use an element selector, and in order to make this button look like the branded button we want for the site, we'll add a background‑color, padding, border, border‑radius in order to round out the corners a little bit, and then change the color of the text. Here, I'll use the branded color for Bethany's Pie Shop, add in some padding, give it a border. So let's take a look at that. That's a really good start. Now let's round out the corners a little bit by adding in some border‑radius. Here I'll go with 3px. That looks a little better. Now all we need to do is change the color of the text, and the fff is the hex shortcut color for white. Well, there it is, that's starting to look much, much better. So we have a Pies page, with a Home page, and a Contact page. So now in the next module, I'll introduce you to JavaScript, the programming language of the web, where after we cover the foundations there, we'll be able to start adding interactivity to the website.

Up Next
JavaScript is one of the most popular programming languages on the planet, and it's the language that runs right here in your browser. Up next, I'll introduce you to JavaScript, starting from the very basics and take you all the way up into the mechanics that you need in order to make Bethany's Pie Shop a real website.

Introduction to JavaScript
Introduction
Computers are funny. They do only exactly what you tell them to. Well, lucky for us, we have a long list of ways to help us talk to computers. While a processor, or the central brain of a computer, only really understands one language, if you want to call it that, of 1s and 0s, as developers, we have an array of programming languages that help us take the commands we want to give a computer and turn it into something that it can understand. One of these languages is JavaScript. JavaScript is the language of the web. It runs on the web browser and can also run on the server. But here we'll focus on the code that you write in order to make a web page interactive in the browser. Now as every language is made up of a series of small building blocks, JavaScript is no different, there's some fundamentals that you need to know in order to get started using JavaScript. And in this short introduction, I'll acquaint you with just what you need to get going. So let's begin by saying hello to JavaScript.

Strings
To get things started I'll open up a blank page in the browser because right now the HTML doesn't matter. So up in my location bar all type about:blank, and that gives me this nice, clean, empty page. Now I'll open up the developer tools and switch over to the Console tab. Now, an important keyboard shortcut to know is Ctrl or Command‑L, and that clears the console. So if I end up with some gibberish in here and I want to clean that out, I can press Ctrl or Command‑L and make that go away, or you can hover over the top here and it'll show you the command to clear the console. I'll be using this command as we go along in order to keep the console nice and tidy. Now, from this console window, we can type some JavaScript commands in there, and in the background, the browser's interpreter will execute the code entered right here. Now an interpreter is just a little program that knows how to take the JavaScript commands we type and interpret it line by line into something the computer can understand. So let's greet our new friend the browser and start typing hello and press Enter. That's not very fun. The first thing we're met with is an error. That program was supposed to be fun. Well, it says hello is not defined. Remember how I said that computers are really picky? Well, we need to tell the browser a little bit more about what's going on and what we want it to do with what we've entered into the console. Now if you take a little closer look at to what we typed in, you'll notice that our message hello is a word, yes, but it's more than that. In fact, it's a series of letters strung together in order to make a word. So what we need to tell the computer is just that. We need to tell the computer that it's a string. Now strings are special in JavaScript, and really in any programming languages, because they represent text, or a series of characters and spaces strung together. So let's try this again. Instead of just typing hello, I'll surround the word with quotation marks. Now when we type in hello inside the quotes and press Enter, instead of an error, it shows us the string that we typed in. This is great because now the browser knows that this is a string and we can unlock the power of JavaScript to work with strings. Let's say we want to know something about the characters in our string. We could just type hello.length, and this returns the number of characters that are in the string. So strings are a series of characters, including whitespace, like line breaks and spaces, just like if we type a different message. And really, working with JavaScript is a lot of fun. Well, the fun doesn't stop there. JavaScript is actually quite good at dealing with numbers as well.

Numbers
It's probably no surprise to you that computers are quite good working with numbers. In fact, if we go back over to the console, when we type in a number, you'll notice that the browser immediately recognizes the value as a number. There's no special formatting needed here. In fact, we can type in what you might think of as an equation, and the browser will figure out the answer for you right here in the console. So if we type, the answer pops up immediately. So if you're ever in need of a calculator, your web browser can always help. Now, what we just typed in, 1 + 1, looks kind of like a mathematical equation, and it is. But in terms of how JavaScript sees that line of code, what we're talking about is an expression. Expressions are lines of code that when evaluated give you a result. The concept of an expression goes way beyond just working with numbers, so we'll talk about them more a bit. But I want to at least introduce you to the idea here. So when dealing with numbers, you can have the browser evaluate any type of formula or expression that you can think of. What's even interesting about the console for math is that you can see the incremental values as you type out an equation. For instance, if I type in 6 * 6, notice how when I close the parentheses, it gives me 36. But I want to divide that by 2 * 3, and that gives me 6. Now, in our expression, we're using mathematical operators, the plus sign, that slash to divide, and even parentheses. When it comes to programming, we use those operators for more than just giving instructions in mathematical equations. But before we go down that road, let's first talk about variables.

Variables
Now having numbers and strings in your program, don't get me wrong, that's great. But, really, there's not a lot you can do with them just by themselves. One of the ways that programs, and in our case web applications, are able to do all that they can is because they use variables. Now you could think of a variable as a container, a container where you can change the contents at will. So looking at the console again, if you recall from our discussion with strings, if I wanted to type my name as a string, I would type Craig. And, again, this is great, but it's just not that useful. If I take that same value and set a variable equal to my name, then I can change the name and always get to the current value just by looking at the variable. I'll show you what that means here in just a minute. In JavaScript, the way we tell the interpreter we're declaring a variable is that we start off the line with the word let, and then we give it a variable name. In this case, we'll create a variable name and call it name, and we'll set that equal to my name. Now something powerful just happened here because now, if we take a look at the contents of the name variable, you can see it's Craig. But I can also change that value. Now I can set name equal to John. So if I go back and ask the variable for its value again, this time I get John. Now notice something special that just happened here. When I created the variable, I gave it the keyword of let. So in English, I'm saying, let a variable with the name of name have the value of Craig. But when I want to change that value, I simply set name equal to the new value, which is John in this case, and I can change that value at will. So if I want name to equal something else, I can do that. Now right now I'm showing you how to work with strings, but you can declare variables for numbers and arrays and functions and all these other things we haven't talked about yet. But a variable is just a container for values. And, in fact, there is one type of container where you can set the value once and then you can't change it again. And that's called a constant. I realize that it sounds a bit strange, the idea of having a variable, which kind of stands for something that varies, but you can't change its value. So while I want you to think of variables as containers for things that can change, you can also think of them as placeholders for other values. So when we're dealing with variables that are assigned a value and then don't change after that, what we're really working with is a placeholder for an actual value. So suppose for a minute you want to create a program that processes orders. In this system, we want to set the maximum number of orders for any given product. Well, we need a container or placeholder for that value, and we want to declare it in such a way that it can't be changed later on. So in JavaScript, the keyword const, which stands for constant, does just that. So this declares a variable named maxQuantity that tells the interpreter that once the value is set, it needs to remain constant and it can't be changed. In fact, right now, if we try to change the value to 3, we get an error saying that we're trying to assign a value to a constant variable, which isn't allowed. So you use let when you want to create a variable with a value that can change, and you use const when you want to ensure the value doesn't change. And you'll see both of these types of variables pop up as we implement the code for Bethany's Pie Shoppe. Now there's still more to discuss when it comes to variables. But for now, let's keep moving. We'll take a look at what the plus sign and the equal sign and really the role and purpose of operators are in JavaScript.

Operators
When you think of the plus sign, chances are the first thing that comes to mind is math, 1 + 1 is 2, and that's exactly the result that we get from the browser. But what if we tried to use the plus sign with a string? Well, if we type "Craig" + "Shoemaker," what we get is a new string where the first and the second one are stuck together. In programming terms, we call this being stuck together concatenation. So "Craig" and "Shoemaker" are concatenated together to make a new string. Now normally I'd add a space between my first name and last name. So I have a couple options. I could type + and then a space inside quotes, and that creates a new string that displays my name correctly. But I can also type my name with a space and then + "Shoemaker," which results in the same value. Let's turn back to numbers again for a second. What do you think would be the browser's response if I type an equation, including the answer? In other words, if I type in 1 + 1 = 2. What do you think the browser will say? Well, we get an error, and that seems somewhat strange, right? That's because when you're in JavaScript, when you use a single equal sign, you're telling the interpreter to set a value equal to something. Just like when you create variables when you type let x = 1, the single equal sign tells the browser that the variable named x will point to the value 1 in memory. So with the expression like 1 + 1 = 2, the interpreter is trying to set 1 + 1 equal to 2, and you can't change the inherent value of what the expression of 1 + 1 is. It just doesn't work that way. So to get around situations like this, many programming languages, including JavaScript, use multiple equal signs to denote equality rather than assignment. What I mean by that is that if we change our expression to read, 1 + 1 === 2 with 3 equal signs, now we get back what's called a Boolean value. Boolean means it's either true or false. And 1 + 1 indeed does equal 2, so the value that's returned from this expression is true. So what do you think would happen if we try to evaluate 1 + 2 = 2? Well, that's going to give us false because 1 + 2 does not equal 2. So there are a number of different operators available in JavaScript. In this course, we'll be using the plus sign to do some concatenation and the equal sign to assign values. And, of course, the triple equals to evaluate whether or not an expression is true. Knowing this now, we can use the power of the equal sign to start making our code seem like it's making some decisions for us and how we can also use expressions to help provide control on how our code is executed.

Control Flow: Blocks
Now when we talk about control flow within the program, what we're referring to is how the program executes and reads each line of code. Now sometimes it doesn't always execute every line of code. Sometimes it skips some of those lines. And in doing that, that's often what gives the illusion that our program is thinking or making decisions. Now programs are built up of a basic building block of code called a block. So let's take a look at a very simple block first. So here I've created a variable and called it name and set it equal to Craig. Now notice right there at the end of the line, there's that semicolon. That's called a line terminator. And that's what tells JavaScript or the interpreter that this is a full statement. So blocks are made up of a series of statements or expressions. Now down here, I'm using the browser's console in order to print up the value of the variable. So if I save the page, you can see that over here Craig is printed up in the console. Now let me show you something interesting about the name variable. If I declare it again but give it a different value, what do you think will happen? So here I've added another name variable, this time set it equal to Tyler. And so when I save the page, let's see what happens. Well, we get an error because the identifier of name for our variable has already been taken, and it's already been taken because these two variables live within the same block. They're within the same scope in the same block. So, interestingly, what we can do is create separate blocks and then watch what happens. So now I've used the curly brackets in order to create a block around these two lines. And then the first name declaration is outside that block. So when I press Save, is it going to show up with an error, print up Craig, or print up Tyler? Well, let's find out. Since I declared the variables using the let keyword, that gives that variable what's called block scope. So it's completely unaware of the variable that's declared above it because that variable is only valid within this scope. So what do you think will happen if I move the console.log statement outside of that block? Now when I press Save, you got it, it prints up Craig. So blocks group statements together and have an effect on how variables are used. Now let's see how a block is used inside an if statement or what we call a conditional statement.

Control Flow: If Statements
Now let's add a little bit of interactivity to the program. In fact, let's allow our program to make some decisions. We'll do that with an if statement. This if statement, also known as a conditional, is set up to use the if keyword, and then you put an expression between parentheses. After the parentheses, you create a block, so in open curly brace, you have your statements within that block, and then you close it with a curly brace. Now our expression here is a little bit unique. So where the single equal sign is used in order to set a value equal to a variable, if you want to evaluate a variable to find out what value it has, you use three equal signs. Now, in JavaScript, you have a little bit of choice here. You can use three equal signs, or you can use to equal signs. Two equal signs will work, but JavaScript has some very interesting behavior about how it evaluates whether or not things are equal when you use two equal signs. This is called type coercion; it's out of scope for our discussion here, so I'm just going to suggest you use the three equal signs, unless you know a reason of why you don't want to use them. The three equal signs do exactly what you might think. You want to find out whether or not name is actually equal to the string of Craig. So by doing that, we're creating this if statement, and if it evaluates as true, it'll run the code that's in the block underneath it. So let's save the file and see what shows up in the browser's console. And, of course, it says Hi Craig! So what would happen if I changed the value of the name variable? When I save that change, nothing's printed up on the console because we haven't told it to do anything if name doesn't equal Craig. So let's add that portion to our conditional statement. So now, in addition to the if keyword, we have the else keyword. What else does is it gives us a block of code that can run when the original expression does not evaluate to true. So basically this says, if the name variable does not equal Craig, then print this string up on the console. So let's save this change, and now we get our new message. And if we go back and change name to equal Craig again, save that change, you can see that it goes back to saying Hi Craig! Now you can take control of this even more. In fact, you can add as many if statements as you want and create a nesting. So if the first expression doesn't evaluate as true, you can drop down to the next one and so on until it just goes into the else statement like we see here. Let me give you an example. So now instead of just a single if statement, I have else if. So what this says in English is, if the variable of name equals Craig, then say Hi Craig! But if it says Tyler, say Tyler, is that you? And if it doesn't say any of those, then just say Wait, where's Craig? So we can change the variable, set that to Tyler, and there we have our message Tyler, is that you? printed up in the console. But if it's a different name, then we get our default message of Wait, where's Craig? So by understanding the concepts of control flow and blocks, you can add a lot of interactivity to your programs. And so we've been using this little thing called log. This is actually a function, so in the next clip we'll talk about how you can create your own functions and how they all work.

Declaring Functions
Picking up from where we last left off, here we have the code that prints up a greeting in the browser. Now this works great here, but what if we want to use that greeting logic over and over again in different places within a larger program? Now what we could do is copy this code and place it in different spots within the program, but that creates a problem for us. If the logic changes or we find out we have a bug in our existing code, we need to change that in two spots. And trust me, I can tell you from experience, there are times when you will forget to update things in more than one spot. So we always want to try and not repeat ourselves when we're writing code. One of the best ways to do that is to wrap up blocks of code like this inside a function. So to illustrate, let's change the code just a little bit at a time so you can see how a function works. First what we'll do is wrap it inside a function declaration. (Typing) Now what I did is added the function keyword and gave our function a name. So here I called this greet. Then I added the open and closed parentheses and then opened up a new block for my function by adding an open curly brace. Then at the end of the block of statements for my function, I added a closed curly brace and then indented the code in a little bit just to make it easier to read. A convention within JavaScript is to indent code inside different blocks. So you'll notice that the code's indented for my function, and then it's indented a little bit more inside my if blocks. So this tells the browser that I now have something called greet, which we can run over and over again. It creates a container around these blocks of code. So even though I already saved the file, you'll notice that nothing happened over here on the console. And that's because this just declares the function. Now what we need to do is call the function. The way you call a function is you use the name, type the open and closed parentheses, and if it's at the end of a statement, we'll go ahead and add a semicolon. So what do you think will happen as I save the file? That's right, it says Hi Craig. So the same logic that was run before is now run when we call the greet function. So if I call it again, you could see that the same code is run two times and I get the same result twice. So now as my application grows, if I want to use the greet logic, I can call this function from anywhere within the program, and the same exact lines of code will be run each time I call the function. Now this is a great start, but we can really make this much more flexible. So next we'll look at being able to declare arguments so that we can pass data into our function.

Padding Data into a Function
Now, it's really nice that all this logic is wrapped up for us, but it's still pretty limited. We have this block of code that changes what will be logged out to the browser based off the value of the name variable, but there's no real way to change it at this point. So what we can do is add an argument to our function so we can pass the value in to the function. Now, that might sound a little confusing, so let me show you what I mean. Right now the name variable is hard‑coded to the value of "Craig." So every time we call greet, it essentially returns the same value. Now, we can go up and change this value to something else and run it again, but every time we run the greet function, because that value is hard‑coded in, we always get the same result. So instead of declaring the name variable here inside the function, we can move it up into the function declaration. And now that that variable is declared within the function declaration, we can delete it from inside the function itself. So now what we have is a function that just wraps up the logic of looking at the name variable, and now we can pass in different values for name as we call the function. So down here in greet, the first time I run it, I can greet based off of the name "Craig." The second time I run it, I can run the same logic based off of the value for "Tyler." And I can even run it a third time based off of the name "Jacob." So now when I save the file, what do you think will happen? When the greet function is run and the value of "Craig" is passed in from the name variable, we get "Hi Craig!" When Tyler is passed in for name, we get "Tyler, is that you?" And for Jacob, we get "Wait, where's Craig?" So by adding an argument to the function, it makes it much more flexible because now we can pass in data from the outside world and run the same logic against different values. And where things really get interesting is instead of passing in hard‑coded strings to the function, we pass in variables. So, instead of doing this, we could say, let name = "Craig," and now we can pass in the name variable into the function, and there we get our greeting. So within the application, as the value for the name variable changes, we get the expected result. So now that we have data going into the function, let's take a look at how data can come out of a function.

Returning Data from a Function
So now that you've seen how to pass data into a function, let's find out how you can get data out of a function. So I've simplified our greet function here and taken out all the logic just so that we can hone in on what it means to return data out of the function. To do that, we use the return keyword, and whatever follows the return keyword is what comes out of the function when you call it. So here, just to keep things simple, I'll add in the string "Hello." So now when I call the greet function, nothing happens. And the reason nothing happens is because all we're doing on line 14 is calling the greet function, but the function is now returning a value, so we need to do something with it. So instead of just calling it, let's take what comes out of the function and set that equal to a variable. So this line says, let the message variable be equal to whatever value is returned as a result of running the greet function. So when we run this, the string "Hello" is set equal to the message variable. So now we can log out the contents of message, and as I save the file, you can see that "Hello" is printed up on the screen. Now we have the same issue here. We don't want to hard code the return value of our function necessarily, so we could return the name variable as it's passed into the function. And so that takes the value of "Alexis" coming into the greet function, returns the value, sets that equal to the message variable, and then when console.log is run, that's what's printed up in the browser. So let's introduce our logic back into the function, and then you can see how powerful this can really be. So here the function is updated with our greeting logic again, with some interesting variations. Now, starting from the top, you'll notice that I declared a variable named result. Now, this is a practice that I like to do anytime I'm creating a function that has to return a result. It's always best to declare it at the top and give it a default value. Here I'm going with an empty string. Now, based off the if statements that are within my function, I know that variable will get a new value, so I could start off with an empty string, but then the last statement in my function will return the results. Now within my if blocks, instead of just calling console.log based off the message that's generated, I'm setting result equal to those strings. So if name equals "Craig," result gets the value of "Hi Craig!" Just like if name equals "Tyler," the result variable gets the value of "Tyler, is that you?" This is really powerful because it opens up this logic to not just be used for console.log. I could use the same greet function in order to log the result out to the console, yes, but also to print it up on the screen or use it in any other way within my program. So now as I come down and call the greet function, I can pass in "Craig," I get the result of that logic being returned out of the function, and then I can take that result set into the message variable and do whatever I want with it. In this case, I'm doing console.log, but here we're dealing with what's called in programming the separation of concerns. The greet function is only concerned about how to create a greeting based off a name that comes in and nothing else. And just to verify you can see it working, that's with "Craig." We can also pass in "Tyler," and we get the expected result.

Object Literals
Next, let's talk about object literals in JavaScript. Now the notion of objects and what's called object‑oriented programming is a vast subject. And when it comes to JavaScript, there's a lot of different nuances on how the language deals with objects. While all these concepts are powerful and important, for our purposes here, we're going to ease into the discussion of objects by looking at what are called object literals. Now one way to think about an object literal is that it groups data and functionality together. So let's consider a couple of different related variables. So here I've added in a variable for my first name, my last name, and my Twitter handle. So as data flows through my program, as I need that information, I can use these different variables at different times. But sometimes what I want to do is group it all together, so I can pass that data around as a single variable, or what we'll call an object literal. So I can take this same information and group it together. Now, as I look at this information, it all relates to me and I'm a person, so I'll create a new variable and call that person. And what I'll set that equal to is open and close curly braces. This tells JavaScript that the person variable is going to be an object literal. Now if you recall from earlier discussions, essentially what this does is creates a block for us, and so inside this block, I can create properties for my object. Now I'll create the first name property form my object, and instead of setting it equal to its value by using the equal sign, here I use a colon. And while since we're at the end of the line, you might think we need a semicolon, as we declare object literal properties, we'll use a comma instead. Now I can create my last name and finally my Twitter handle. So now it becomes really interesting, because instead of dealing with the individual pieces of data for firstName, lastName, and twitter, I can use just the person object. So when I pass person into console.log and we look at the browser console, you can see that it logs out an object to the console. And when I expand out the object there, I have individual properties for firstName, lastName, and twitter. So what that means, if I want to target specific pieces of data within that object, I can use dot notation, so that would be person dot, and then I can access the firstName, lastName and twitter properties. And if you notice something cool, I also have statement completion available to me within Visual Studio Code. So when I press that dot, it'll show you the different properties that are associated with that object. And it becomes even more interesting when we add some behavior together with this data. So you remember our greet function from before? Well, we can add that in here as well. This time, instead of declaring a string, I can declare this property as a function. And inside the function, I can log out my greeting. And here I'll just say my name is Craig. Now inside the function, I have access to the properties of this object by using the this keyword. Now there's a lot that goes on in JavaScript with the this keyword, but for right now, we'll be able to use it here within this function. So now I can come over and call that function directly off of my object. So when person.greet is run, I get my message of My name is Craig. So as we implement Bethany's Pie Shops, you'll see objects a lot, especially when we call functions of other objects, just like you're used to seeing under console.log. Now sometimes we have lists of data that we want to use all at one time, and so next we'll look at arrays in JavaScript.

Arrays
When was the last time you went to the grocery store? And when you went, what did you take with you? Chances are, you probably had a shopping list, and that list probably included a wide array of items that you needed to buy at the store, everything from milk to eggs to bread and flour. Now, in JavaScript, an array is just that. It's a list of values. So let's take a look at this working here in the browser. Now, the way you declare an array, or the way you create a list, is declaring a variable and setting it equal to open and closed square brackets. This bracket notation is what tells the browser that you're declaring a list or an array. So, let's start working with a series of numbers. We can fill this list out by adding in values with commas between them. So now when we log the array out to the console, you can see that it shows us this list. In fact, I can expand the list; we can see, the individual values within the array. Now, arrays are pretty flexible. It doesn't have to just work with numbers. In fact, you can do strings as well. So here I've created a list of names, and so when we save that, you can see that the array shows up with that same list of names. But you can also mix different types of data within an array. In this example, I have a number, a Boolean value, and a string. And when we look at the result in the browser, you can see that the same values show up in their places inside that list, all being different types of data inside the array. Now, as you take a look at this list, you'll notice there's some numbers associated with each value. So here, for the first one, it has 0, and then we have 1, and then 2. This is called being indexed at 0, which means that the first value in the array is accessible by its index or value. Now, I know that doesn't really make sense, so let me just show you what I mean here. Right now, I'm passing the array variable into console.log. But if I want to access the first value in the array, I can use the open and closed brackets and then pass in the index or value. So if I want 100, I can pass in 0, and now when I save that, it just returns the value for 100. So given the position in the array, 100 is 0, true is 1, and JavaScript is 2. Now, the brackets used here are a little bit different than the brackets used in order to declare the array. Because up here, what we're doing is we're giving the values for the array, and down here we're accessing the values for the array. But once we have that array, once we have that list of values, there's all kinds of neat things that we can do with it. We can take those values and reverse them. We can get the count of the items in the array, which in JavaScript uses the length property of the array. And you can even add and remove items from the array. So if I wanted to add something to this list, I can call the push function, and so it returns for me the new length of the array, but I can also ask for it again. And there I get the count of the items that are inside the array. So what's powerful about arrays is you have this list of data, and then inside your program, you can access each one at a time and do something interesting with them. But to do that, we need to use a loop, and so we'll look at loops next.

while Loop
Have you ever heard the joke about how the guy got trapped in the shower? Well, he was looking at the instructions on the shampoo bottle, and it read wash, rinse, repeat. Yeah, he never made it out. Well, these set of instructions created a never ending loop, and loops are powerful constructs when it comes to a programming language. They give you the opportunity to do what we call iterate, or do something over and over again, and in context with our last discussion on arrays, you can iterate over lists of data as well. Alright, well, let's start out simple and see what it looks like to work with your first loop. Now to use our loop we'll implement some logic that does some counting for us. So let's say we want some code that will count from 0 to 10. Well, we'll start off by creating a couple variables to give us the starting point and the ending point. Now when we think about what you want to do in terms of normal English language, you want to keep on counting while the value of your current count is less than the maximum. So you'll count from 0, 1, 2, 3, 4, all the way up to 10, and you'll do that while the current count is less than the max. In terms of JavaScript syntax, there's a keyword called while which we can use in order to create this loop. While takes an expression, and as long as it returns true, it will keep executing the block that is underneath the keyword. So we want it to keep processing while count is less than the maximum. As it executes, we want it to print out the current count, and then to make sure we don't get stuck in the shower or inside an infinite loop, we need to make sure to increment the counter. So when we get to the end of this block, we want the count to equal whatever the count is, plus one more. And now when we save the file, you can see that it uses a loop to count from 1 to 9. Now, why did it go from 1 to 9? Well, it actually didn't. The console scrolled off the area a little bit here, and you can see that it went from 0 to 9. Now, if you recall from our conversation about arrays that are indexed at 0, this is doing the same thing. Our count starts with the value of 0, the block inside the loop executes 10 times, so starting from 0, we go all the way to 9 by implementing the count by 1, 10 different times. So while loops give you the opportunity to create a loop which repeats the same instructions while an expression is true. So as long as count is less than the maximum, then these lines of code will run. Now, while loops are useful, but you don't see them as often as another type of loop, and that's the for loop. We'll look at that next.

for Loop
Picking up where we left off with the while loop, I'd like to show you another loop called the for loop. Now the for loop is a little more cryptic, and that's because the syntax is a bit more compact, but the way it's set up, it gives you a lot more flexibility in how you can work with objects and data inside the loop. Here, let me show you what I mean. With our while loop, we declare these variables outside the loop and have to manage the count's value down here at the bottom of the loop. Let me paste in a for loop and you can see that the syntax is different, but it still prints out the same result to the console window. So this is the for loop. Now, before I go into the mechanics of how the loop works, if I save changes to the file and take a look over at the console, you'll see that the result that we get is identical to what we had with the while loop, and as we look at the anatomy of this loop, you'll begin to recognize some of the same types of constructs that were present in the while loop. So first, we have our counter. Usually, you'll see for loops use a variable name of i to begin with. This generally stands for indexer or the index value of the loop. So it begins with an initial value of 0 for i. Now the loop continues to iterate while the value of i is less than 10. So before with our while loop, we had a variable called maximum, and here, we're just setting the maximum value explicitly to 10. Now, each time the loop executes before it runs the block again, it increments the value of i. Now this is a new notation and what this is is shorthand for saying i = i + 1. So, for instance, instead of having to write something like this, the shorthand of i++ is doing the same thing as i equals i + 1. So once again, the loop is initialized with a variable named i, it's default value is set to 0, it continues to run while the value of i is less than 10, and every time it runs it increments the value of i by 1. So now this loop is much more compact and the indexer is readily available to us. So how might we use a loop like this? Well, let's take an array of numbers and see what that looks like. So this time, instead of telling the loop that we want it to run while i is less than 10, instead what we'll do is have it look at the length of our numbers array. And now we can use the double bracket notation in order to pass the index value into our array in order to get the individual value from the list. So again, as this loop executes, i is initialized to 0, it will continue running as long as i is less than the length of our array, and in this case, that's 3, and then each time it runs, the indexer or the i value is incremented by 1. And so each time it runs, we can use the value of i to extract the number of the appropriate position. So I'll save the file, and here within the browsers console window, you could see that it prints up 1, 2, and 3, and of course, that works on any type of array. So if I were to change this to true, change this value to 200, and this to a string, as the loop works against the list, it prints out the value for each one of those items. Now arrays have a function that makes working with loops even easier for array values, and that's called for each, and we'll look at that next.

forEach Loop
Now JavaScript arrays feature a really handy function called forEach, and what it lets you do is iterated over the values of an array one by one. But the syntax is so much more simple than a for loop and a while loop. So here I have an array of day names, and so if I want to print something up for each one of those I can start off by calling the function forEach off of the day's array. Now this function takes a function. Now this is a feature inside of JavaScript where a function can automatically call another function. So inside this function we'll create a new function, and you'll notice that we're not giving it a name. So this is called an anonymous function, or again, a function that has no name. Now forEach is going to pass some values as arguments into my anonymous function. The first thing will be the data for each item on the list, so we'll give this argument a name of day. It also passes in the index value of the item within the array. This is really handy, so we're not left guessing at what position in the array the value that comes in is at within the array. So now we can use this in order to print up some information within the console window of the browser. So we'll do console.log. And now I'll show you something new when you're working with strings. Instead of just using quotation marks, I'll use the backtick character. Now this creates a template string which allows us to do something really interesting. Here I want to print up what the day is, so I'll do day: space, and now I want to get the value of the day variable and stick it into my string. I can do that really simply by putting in the dollar sign and open and close curly brackets and then put day right in there. I also want to show the index value, so I can do the same thing by grabbing the value of the variable index and placing it inside my string. Now I'll get rid of these extra spaces so you can see everything on one line. So what this does is creates a string of telling me what the day and the index is for each one of the items in the array So as I save the file, you can see the over here on the console, I've got Monday at index 0, Tuesday at index 1, and Wednesday at index 2.

Next Up
Well, congratulations, you've come a long way learning about the basics of JavaScript. In the next module, we'll push things a little bit farther and show you how you can begin creating interactivity with JavaScript in your website.

Creating Interactivity with JavaScript
Introduction
In this module, we cover some of the building blocks you need to create interactive web apps. We'll discuss how to write code that can respond when certain things happen in the browser, like when a page is done loading, a button is clicked, and so on. We'll also review a wide array of built‑in features and functionality available to you through JavaScript as you build web apps. And, finally, we cover how to determine browser support for different features and what to do if that functionality isn't yet supported.

Selecting Elements
One of the fundamental actions that you'll use JavaScript for in working with the web page is selecting elements on the page. Now I've created this sample page that just renders out a couple of different cards, one for myself and my friend and fellow Pluralsight author, John Papa. As we take a look at the HTML, each card is made up of a section element that has an ID, which represents our name, and they both have the class of card. So when I want to access one, specifically, I can use the ID attribute, and when I want to access these elements together as a set, I can use the card class. And so inside the card, there is a title and a list for each one of the links. Now to use JavaScript in order to access these elements, there is a number of different ways I can do that and one of the first ones is to use a function called getElementById. Now it's available off the document object. Now, if we look at the document just in and of itself, you could see that this object represents the web page or the document that's running within the browser. So by calling document.getElementById and pass in an ID value, what it returns is a reference to the section element because it has the ID of Craig Shoemaker. And so, if I wanted to get reference to John Papa's card, I could call document.getElementById and pass in the ID value of John Papa. Now that works great for accessing elements that have a specific ID, but what if I want to select items based off of their class name? Well, I can do that very easily as well. Here, I can use document.querySelector. Now, what we pass into the querySelector function will seem very familiar to you. This will take the same type of selectors that we used in building CSS rules. So in order to access my card class, I type in .card. Now the querySelector function returns the first match of your selector. So here, you can see that it returned the section for Craig Shoemaker because that was the first item that had the class of card. Now we can get all of them just as easily by calling document.querySelectorAll. And now when we pass in card, what's returned is a node list of all the matching elements. So there is the first one and the second one there for John Papa. Now, the queries that you can pass in to the querySelector function can be very simple like I've shown you or even a little more complex. Taking a look at the HTML again, I have an anchor element that points to my Twitter profile. Now that element is made up of an a tag with an href attribute that has a value of https twitter.com/craigshoemaker. So we can take these same values and format them in a selector to use with querySelector. So here, we'll look on the page for an anchor that has the href value of my Twitter handle. So to do that, we'll do document.querySelector and then build up the selector for that element. So that's an a tag with an attribute of href that equals the value of my Twitter profile and notice that it returns the correct element. Now there is one more thing I want you to notice as well, see how I used the double quotes on the outside of the selector and the single quotes on the inside. The quotes in the inside are necessary in order to tell the selector that we're searching for a string value that the href will be equal to, but we can't use the double quotes because that would signal to the browser that the selector was going to end early. So any time you need to use quotes inside of quotes, you can use the single quotes inside the double or you can use the double quotes inside the single. The important thing is you just have to be consistent. Okay, now that we can select elements on the page, let's look and see how we can work with them once we have access to them.

Working with Elements
Now that we're able to select elements on the page, let's see what we can do with them. One of the actions that you can take against an element is to change attributes in JavaScript. So with these links here right now, if I click on one of them, they open up in the same browser tab as my example page. And if we look at the HTML, the anchor has an href attribute and a class attribute. But there's an attribute that we can add named Target that allows us to designate the destination of the link location. So let's go down to the script on the page and add a little bit of code. Now what I'm doing here is using document.querySelectorAll to select all of the elements on the page that have the tag class applied to them. So this is all of the links within each one of the cards. Once I have access to those links, I can iterate through them. Now I'm using the forEach function here, and even though this looks like an array, technically what comes back from querySelectorAll isn't an array. It's what's called a node list, but they've added a forEach function for us, so we can use that here. And it works just the same way it does within an array. So inside of forEach, I create an anonymous function and an argument for the individual link. So each time it goes through this loop, the link variable will be in reference to an individual link on the page. From there, I can call the setAttribute function and tell it that I want to add an attribute called target and set its value to blank. And since all of this runs within a loop, it does that action for each one of the links on the page. All right, well, let's switch back over to our page and see how it behaves now. Now when I click on any one of these links, they all open up in a new tab. Now the setAttribute function works to either create an attribute that isn't there yet or update an attribute's value. But we can also ask the attribute for its value by using the getAttribute function. So here I'll open up the developer tools, right‑click on this element, and select Inspect. And if you recall, when I come into the Elements pane, it automatically creates the $0 variable for me in order to select the element. And so I wouldn't use $0 when I'm coding a web page. But here, I'd like to show you how you can do it for experimentation within the browser development tools. So now I'll switch over to Console, and I'll verify I have a value for $0. So this variable is now pointing to this element. Now from there what I can do is I can ask for the value of a specific attribute. By calling getAttribute and passing in the name of the attribute that I want to look at, there I get the value of our new target attribute. I could also ask for the href value. And I could also remove an attribute. By passing in the attribute name, that removes the attribute from the element, so now you can see that the HTML has been updated so that the target element is not there. If we look over at this other link that we weren't working with, you can see it has the target attribute. So now when I click on Twitter, instead of this opening up in a new tab, it opens up in the same tab, all because we've removed that attribute. Now there's one attribute that acts a little bit different than the others, and that's the class attribute. So in the next clip, I'd like to show you how to work with the classList HTML attribute.

classList Property
Selecting elements is the first step, but once you have access to those elements, it opens up all kinds of possibilities for you to be able to do something with them. So here we have our page that has our cards on it, and each section has a class of card. Now, what we'll do is run some code that will update the classes that are applied to the card. This is how the page looks when we load it into the browser, and using JavaScript, what I want to do is locate an element that has the class of card and add to the list of classes that are applied to this element and add the dark class. With the dark class applied, when we take a look at the web page, you could see that the card is rendered with a dark theme. Now, what I just did was to add it directly here into the HTML. And so now I'd like to show you how to do the same thing using JavaScript. So we're back to the default state of the web page, and so I can use document.querySelector to get access to the element that has the card class. So now when we take a look at the card variable, you can see that the first card is selected. Now, from there, I can change the classes that are associated to this element. Now, you might think that I could go to card.class and set that equal to something, but that does not work in JavaScript. The word class is a reserved word. And so here what we'll use is class list and you saw that show up in the suggestions as I was typing. So here, by accessing the class list, I can call the add function and pass in a class name. Here, I don't add a dot before the name. Because this isn't a selector, I'm passing in a name. And so now as I press Enter, the list of classes that are associated with that element now includes dark, and in fact, we can look at that list here and you can see it returns back both card and dark. Now what if I want to remove it? Well, I can call card.classList and run the remove function. And so now when we look at the class list, the only value that's in there is card.

Script Tag
One of the elements that you've seen me use a lot but we haven't really discussed yet is the script element. Now the script tag is the element that we use on a page to execute scripts. The location of the script tag is important. When you think about the details of how a website works, when a page is sent to the browser, the code is processed from top to bottom. And, remember, HTML and CSS are responsible for the structure and layout of the page while the scripts are responsible for the behavior. I bring all this up because it's for these reasons we want the script tag near the bottom of the page. Often it shows up as the last element before the body's closing tag. This ensures that our pages aren't halted from loading and being styled due to a script that didn't work quite right. So as you've seen throughout this course so far, I've added JavaScript to the script element. Oftentimes something like this. (Working) There are times, and probably more often than not, when you'll want to move the script into an external file. We move JavaScript into its own file for a lot of different reasons. One is that the scripts are easier to write and maintain when they're in dedicated files. You can load as many script files as you want into a page, and by splitting up the code and the logic, it just makes your applications easier to work with. The second main reason is that browsers make copies of files that they requests from the server. This is called caching. When a file is cached, the browser loads its file from a saved copy, rather than trying to make a new request to the server. Now this speeds up the web a lot. So if you have a script file that many pages of your site use, then adding it as an external file makes a lot of sense so you can take advantage of browser caching. There are other really good reasons to use external scripts, but these are the two main ones that are relevant right now. So I have an external script provided for us, and just so that you can see the location, I created index.js right next to index.html. If we go and look at the contents of that, it just logs out "Hello from a script file!" Now to reference it, the first thing that I want to do is remove all script from inside the body of a script tag itself. So it's going to look like this. And then our script tag will have a source attribute. From here, VS Code is picking up the files that are in this folder, and I can select index.js. And then I need to add a type attribute and set that equal to text/javascript. This attribute is important because it tells the browser what language the script is coming in as. With modern web development, the only client‑side scripting language we use is JavaScript, but it's added here just for completeness. Now some tags within an HTML page are self‑closing. So if you notice, the meta tag up here doesn't have an associated closing tag. The script tag does need the closing tag though. Even though we don't put anything in between the script tag, we still have to explicitly close it here. So now when we save the file, the page reloads, and we get our message, "Hello from a script file!" Next, let's take a look at how the window object is used inside of the browser and through JavaScript.

Window
The Window object is the context for scripts running within a web browser, and we'll use the finished version of Bethany's Pie Shop to illustrate. So the window generally refers to the window that's running inside a current tab. So if I open up this page in a separate tab, there are two different Window objects of where your script will run, even though they're technically within the same website. They're independent pages, so they get an independent context. The window hosts the document object, which is the DOM for this tab. So if we take a look at the window, you can see there are scores of functions and properties available off the window. And much of the functionality of the browser is available off of the Window object. Now, from here, we have access to things like the location of the Browser tab. And then from here, we can get all kinds of information about the URL of the page, and even the different segments that make up this location. So we could do an entire course on the Window object inside the browser. But for now, what you need to know is that we'll use the Window object to get access to the built‑in functionality of the browser.

Debugging
If you use nothing else inside the browser developer tools, you will use the debugger. The debugger allows you to stop code from running at a specific point so you can inspect what's happening right at that line of code. Now, I've written a simple script here, and if you haven't already noticed, I've introduced a bug into my code. So I'm concatenating together my first name and last name, but here, when I go to use them together, I use the variable called firstName instead of first. So, if we save the file, you'll notice that I get a reference error, and it says firstName is not defined. Now this is a very simple script. We can see the error very easily. But let's imagine for a moment that this bug is hard to find. Within the browser developer tools, I can go over to the Sources tab, and when I click on index.html file, it shows me right where I have an error for this line of code. Now, if I come down to the line numbers and I click on one of the lines, you'll notice that it's highlighted with this blue arrow. This is called a breakpoint, and you can see in the window over here on the right that it shows the list of breakpoints. A breakpoint means that this is a point at which the execution will break, or essentially stop, and allow you to examine what's going on in the code. So now with that breakpoint set, I can refresh the page, and notice what happened. It highlighted the line, and it shows up in the top that it's paused in the debugger. Now, as I look around on my page, I can hover over variables, and I can see the at the variable named first has a value of Craig. The variable of last is not yet declared because we haven't executed this line yet. So, I'll come over here and step over the next function call, or you can press F10, or CTRL+apostrophe, either one of those will work, and now the next line of code has been run. So the variable named last now has a value of Shoemaker. But you'll notice it didn't keep going. It stopped at the next line of code. So at this point, I can hover over last and see that I have a value. And then I see firstName. Well, that doesn't have a value. And so by stopping the code as it's executing, I have a much better chance of figuring out what my problems are. So, here we've realized, firstName is not the variable that we need. What we really need is to call that first. So now I can switch over to the editor. Make the change. Now remember, it's still stopped here on this line, so I'll let it run, and refresh, and now it hits the breakpoint again. So first has a value of Craig, step over the next line, last has a value of Shoemaker, and first and last now have values. I fixed my bug, and now the name variable has CraigShoemaker as its final value. You'll notice over here on the right‑hand side, it shows the current script that's running and all the variables that are currently in scope and their values. So by setting breakpoints and using the browser's debugging tools, you have a lot of power available to you in order to debug your applications. Now that we have a good view of what it takes to write and debug code, let's start writing some code against the browser and find out how to work with HTML elements on the page.

Events
Events in programming languages, just like in real life, signal when something happens. When an event occurs in a program, the application sends a notification to the rest of the code essentially saying, hey, something happened here, and you get to select which messages you want to respond to. Now, for instance, there's an event that fires when the page loads. You can also listen for an event that fires as a button is clicked. You can even tap into an event that lets you know when a change in the orientation of your mobile device has occurred. And these are just a few, among many, events that you can use in your app. In JavaScript, you set up your code to listen for events. So let's take a look at the function that allows us to respond to these events, and that function is called addEventListener.

addEventListener Function
AddEventListener is the function you use to run some code when a given event takes place. The syntax for this function is made up of a few different parts. Here addEventListener is being called off the window object. But now we need to tell the browser which event we're interested in. The name of the event is added first between quotes here because the name is a stream. Now there are dozens of events to choose from, and in the coming examples, I'll show you how to use a few. The second argument of the function expects a function. This is similar to how the forEach function worked when we spoke about arrays, where the function defined here is called when the event notification is sent. This is an anonymous function, and the function being called gets a reference to an object that contains information about the event that was just raised. Often you'll need to access different information to find out more about what's happening in the program, and that will be available within the event object. Inside the function is where you write the code that's meant to respond to the event. Okay, let's take a look at some real implementations and how you can respond to a few different events in JavaScript.

Demo: Events
So here we are back with our example page, and one of the first events that I'd like to hook into is to know whether or not the page is completely loaded within the browser. Now the reason this is important is because our page is represented in the browser through the Document Object Model. Now if you recall our discussion from cascading style sheets, where we talked about the Document Object Model, or the DOM, it's an in‑memory hierarchical representation of the elements that make up a web page. When the browser requests a page, the response from the server includes HTML that's read by the browser. Based on the structure defined in the HTML, elements are created in‑memory that correspond to the markup in the page. Now load times can vary depending on a number of factors. Sometimes web pages load so quick that it seems instantaneous to our eyes, but to a computer, there's always a certain amount of time that elapses before a web page is completely loaded and rendered inside the browser. Since there's this delay in time, even if it's slight, the code we write needs a way to know that, indeed, that page is loaded before attempting to run. So the name of the event that tells us that the page is loaded and ready to work is called DOMContentLoaded. So the first thing that we want to do is go to the window object and call addEventListener for DOMContentLoaded. Then we'll create an anonymous function that's called when the event fires. And now within the body of this function, we can add in our logic that runs as the page loads. So we'll log out to the console saying that the page is loaded. So now when we save the page, it's reloaded, and only until all of the contents of the page are loaded into memory, and each one of the HTML elements are processed in the DOM, is this event fired, and we get the console to report that the page is loaded. Now there's nothing to our page, so it goes really fast, but this is the place where you want to begin writing code if you're going to use any elements on your HTML page. Now if we wanted to interact with a button on the page, we could do that simply here within this event. So I'll first start off by creating a new element for a button that we can click on. I'll create a button with the id of click‑me and the text of Click Me. So now down at DOMContentLoaded, I can add in the logic to interact with my element. The first thing that I want to do is select the element on the page. Here, I've used the querySelector function to pass in an id selector in order to find that element on the page. Next, we'll add an eventListener on the button to listen for the click event. And with that, I can log out to the console that the button was clicked. So as I save the page, and it reloads, I get a button here rendered on the page. Now it's so big because I've increased the zoom level to make it easy to click on. So when I click on that, I get a message logged to the console saying that The button was clicked. And lastly, I'll show you how to handle the event of when the device orientation changes within the browser. Now, this is an event that only fires for mobile devices, so I'll show you how we can simulate that here within the desktop browser. First, we'll add an eventListener for orientationChange off the window object. Now we can look at the screen object in order to get orientation information about the device. We can get the angle and the orientation type, and we can take that information and log it out to the browser. So as I save the changes, when we look over in the console, you don't see anything show up, but remember that we have the mobile emulator available within the browser developer tools, and I can switch over to that, and you'll notice that as I switched over to the mobile view, it fired this event. Expanding the window out in order to make it a little bit easier to see, if I click on this button for Rotate, you'll notice that as the event fires, the type goes from portrait primary to landscape primary, and from 0 degrees to 90 degrees. Now, there is a wide array of events that are available to you as you build your web apps, and we'll be using a number of them as we finish up the implementation for Bethany's Pie Shop in the next module. But next, let's get a feel for what type of APIs are available directly within the browser.

Native APIs
The letters A‑P‑I stand for application programming interface. Now that's just a fancy way of saying that there's some code that you can use in order to work directly with the browser's functionality. Putting it another way, using the browser's API, you can control the features and the behavior of a web browser. The best way to get an overall look at what APIs are available is to go over to the MDN web docs, and we'll bring up the web API page that lists all the built‑in functionality of a web browser. Now, by looking around on this page, you'll be able to see that there's a vast array of functionality that you can tap into. Want to draw something on the page? Well, you can use the Canvas API. Want to request an additional file from the server? Fetch does that. Want to create drag‑and‑drop interaction on your page? Well, the API is right here. What about saving data in the database? The tragically named IndexedDB app I can do that for you. And the list really does just go on and on. But there's one problem. Not all of these APIs are available in all browsers. So how do you know what you can use and whether or not there are alternatives in case something you really need isn't available? Well, I'll tell you right now, alternatives do exist, and we'll discuss those next.

Fallbacks and Polyfills
Sometimes the API you want to use isn't fully supported by browsers, and we'll look how to determine browser support next. But for now, I want to introduce a few terms regarding API support. In situations where an API support is inconsistent, there are two types of scripts that you can include on your pages that help compensate for the missing feature. A fallback is a script that your browser can fall back to if the built‑in functionality doesn't exist. The fallback often doesn't do as much as what the native API is supposed to do, but they exist as an alternative to built‑in browser functionality. A polyfill, on the other hand, is meant to mimic built‑in browser functionality by already using supported features. The main benefit here is that a polyfill is specifically built to have the functions, objects, properties, and behavior that work exactly the same way the built‑in browser functionality is supposed to work. This way, once browsers do fully support the API, you should be able to remove the polyfill, and everything should just work. Now that's the promise. But be warned, you should still do extensive testing before you make changes like that. So now that you're familiar with fallbacks and polyfills, let's take a look at a few tools that can help you when determining whether an API is supported well enough for your application.

Browser Support
Determining browser support is important because you need to know that the code that you write will work with the web browsers that are accessing your site. Now, there's a couple tools that you can use in order to help make these decisions. The first one is HTML5 Please. This website lists different native APIs and gives you some hints on how well they're supported and what to do if they're not. In conjunction, caniuse.com is an excellent resource that brings you a broad spectrum of statistics regarding how well APIs are supported on different browsers. You saw caniuse.com a little bit when we talked about CSS, and we'll use it a bit more here. So we'll take a look at a couple different APIs here within HTML5 Please so you can get an idea of what this website offers. First, let's take a look at the API of local storage. This is a built‑in API that allows you to store information within a web browser. You'll notice that HTML5 Please has marked localStorage as use. So this is a fully supported API, meaning that you can use it with high confidence in just about any web application. As we scroll down to the bottom, you'll notice there's a link down here that says View browser share %. When we take a look at that, that brings us to caniuse.com directly to the section on localStorage. Here we get an idea of browser support and any extra resources that are available for this API. Now, localStorage is a really well‑supported API, so let's look at something a little different. Now, Web Workers are marked as used, but with a fallback. So the advice here is that there may be a small percentage of web browsers that don't support the API, and it gives you some ideas of how to work around that if you need to have 100% browser capability. All right, let's look at IndexedDB. This API is marked as caution with a fallback. So here it gives you some recommended polyfills, IDBWrapper and the IndexedDB Polyfill, and when we go over to caniuse.com for IndexedDB, scrolling down to the Resources tab, you'll notice that it has links for polyfills and detailed information about places where there might be some deficiencies in the implementation. But you'll notice from the chart here, almost every modern web browser supports IndexedDB. All right, let's look at one last example. The WebSQL API is marked as avoid. This is a deprecated API, and you really don't want to use this API unless you have a very specific reason to do so. And the advantage here is that the website gives us all of that knowledge ahead of time without having to figure that out the hard way.

Up Next
Well, next up, we have the last module in the course where I'll demonstrate to you how to update the rest of Bethany's website in order to collect user data and send it to the server. And this is where it gets exciting because now we get to put in practice all the knowledge that you've learned about JavaScript to update the website to make it truly interactive.

Collecting User Data
Introduction
Well, congratulations. You're in the final stretch to finishing up Bethany's website. The functionality that remains is to read the customer's location, collect contact and other order information, and send it all off for processing. To do this, we'll discuss how to save data in the browser, how input forms work, and how to get acquainted with the geolocation API, which allows us, with permission, to access a user's location. With the local storage API, you could save small amounts of information in the browser. This feature makes it really handy for making data collected on one page available to the next. Using HTML forms will provide a place for users to enter their name, address, and order information, and we'll also add a feature that allows the web browser to request a customer's latitude and longitude coordinates using the geolocation API. So now let's turn our attention towards updating the pies list page to keep track of which pie a customer is ordering.

Local Storage API
To select a pie, a user clicks the Order button. Now, behind the scenes, the JavaScript on the page saves the information about the selected pie and then forwards the browser to the next page. The way we save that data is to use the local storage API. As the name hints, local storage is a place to store information in the browser, rather than being required to send data to the server for saving. Off the local storage object, there's a few functions that you can use to save and retrieve data. Here, the setItem function is used to save data. You pass it a key, which is a unique identifier for your data. You'll use this key later to pull data back out of storage. You also need to tell the browser what to store. So you add a value you want to save as the second argument to the setItem function. Once saved, in some other place in your app, you can pull the data out of storage so you can work with it. Now, for that, you can use the getItem function. Just as with setItem, here, you have to pass the key to request data from storage, and the result is returned from the function. So, now let's go to the pies list page and implement the feature to keep track of a customer's order.

Update Pies List Page: Part 1
Returning back to Visual Studio Code, let's open up the pies list page where we left off. Now let's view the current state in the browser, so I'll open up Visual Studio Code's Command Palette by pressing Ctrl+Shift+p, p or maybe Command+Shift+P if you're on a Mac, and choose Open with Live Server. So this is the page in its current state. It lists the pies, but when I click the Order button, nothing happens. So what we want to have happen is that when the page loads, we want to add some code that runs when you click on the Order button. We want the page to save information about the pie that you selected, and then forward the browser on to the Order page for processing. All right, well, let's go back to the file itself and start implementing the JavaScript necessary in order to create this type of interaction. So I'll scroll all the way down to the bottom of the page and add a script element after the body tag. Now I want my script to run when the page first loads, so the first piece of JavaScript we'll add is an event listener for DOMContentLoaded. So now as the page loads, whatever script we put within the handler here will run on the page. The next thing that I want to do is select the different buttons on the page. So if we go back up to the HTML, you'll notice that each one of the buttons has a data‑ attribute which identifies which pie we're ordering. Now data‑ attributes are special attributes that you can add to an HTML element that give you a chance to add in some custom information. So here, I'm adding information to the button, saying that when you click on this one, you're ordering an apple pie, and when you click on this one, you're ordering the cherry pie. So we can use the data‑ attribute in a selector in order to get access to those buttons. Using querySelectorAll, I can pass in a selector saying that I'm looking for a button that has an attribute of data‑order. Now right now, we don't care about what the value is, I just want a button that has the attribute on it of data‑order. And once it finds each one of those on the page, it adds it to the orderButtons variable. And now that they're in that variable, we can use a forEach loop in order to work with each one of the buttons. As we loop through each one of the buttons, the anonymous function will have access to the individual button, so now we can work on creating the click handler and then adding in the functionality that we need. So let's do that now, let's create a click handler for each one of the buttons as we're looping through them. Using addEventListener, we can tell each button that when we click on it, we want to run some JavaScript. And so now we can do just that. Once we've clicked on the button, since we're using that data‑ attribute that tells us which pie we've selected, we have all the information we need in order to save the order information and then forward on to the next page. Now by looking at the event argument that comes into this anonymous function, we can get the currentTarget. What that means is that this gives us reference to the HTML element of the button that we just clicked on. We need reference to this button for a couple different reasons. Number one, we'll be getting the data‑ attribute value out of the button, but we also need to look at its parent. So let's look at the HTML for one more moment, and you'll see why. Each one of the buttons is inside a container that has all the information we need about what the user has selected. So if they select the cherry pie, we can ask the elements inside this container for the value of the title or what the price is. And so down in our script, we'll start off by looking at the button and then ask that button for its parent information. Once it has access to the parent container, then we can use that to request information about the title, the price, and the description, and I'll show you how to do that next.

Update Pies List Page: Part 2
So as we scroll back down to the script, we can get reference to the buttons container by taking a look at its parent node. And so now that we have reference to the button and the parent container, we can get all the information we need about the user's selection. So now we can build up a small object that contains information about which pie we ordered, what its title is, what its price is, and also the description. To hold all that information, I want to create a simple object literal, and I'll create properties for each one of those data items. So now, to get the unique ID of the pie that we're ordering, we'll take a look at the button and get the value out of the data‑* attribute. So coming from here, when we ask for the data‑order attribute, we'll get the value of cherry‑pie or apple‑pie. Then we can take a look at the parent container, and notice that we can use querySelector against this container. Before, we've often been using querySelector against the window. So that asks the entire web page for any matches based off the selector. Here, we're narrowing it down just to the container. So if we were to select cherry pie, it would only be looking within the container for the cherry pie. And then we use class selectors for title, price, and description. So by running querySelector and a selector for the title class, I can look at the innerText of that element and get the title for the item that we selected. And that's the same thing for the price and the description. Now that we have this object set up that has all the data that we need, we can save it in local storage. So now by calling localStorage.setItem, we'll tell the storage that we want to save this with an ID of order, and then we'll pass in the order object. Now there's only one problem. LocalStorage doesn't know how to save objects. It only knows how to save strings. So what I want to do is convert this object into a string. Now, this will make a little more sense in the next clip, where we'll debug through this code and you can see it happening, but for right now I want to run a function that takes this order object and essentially types it out as a string so I can save it. The interestingly‑named stringify function is available off the JSON object. JSON stands for JavaScript Object Notation, and this is a helper object that we can use in order to work with JavaScript objects. So here we're telling it to stringify it, or take this object and turn it into a string. Now that we have that saved within the browser, we can forward our web page to the next page in the process. To do that, we'll look at the current location of our browser. So if we switch back over to the browser for a moment, the current window location, or called href within our code, is found at the local host server pies.html file. So what we want to do is read this value and switch out pies for order.html. And that's exactly what this code is doing. It's looking at the location of the window, finding pies.html, and replacing that value with order.html, so now we have a new URL that we can forward the browser to. And that's exactly what this last line of code does. It sets the browser's location to the new URL, which essentially forwards our page to the new orders page. All right, well, next, I want you to see this running, and we'll step through the code in the debugger so you can see each one of the variables change as they execute.

Step through the Pies List Page
So here's our pies list page with our newly‑added functionality available. Now let's open up the developer tools, so we can watch what happens a little bit as this goes on. So I'm over on the Application tab, and I've selected Local Storage, and you'll notice that there's no values in Local Storage at the moment. So, when I click on the Order button, it'll gather all the information about the order and save it within a Local Storage. Now, I'm going to click on this button, and it's going to go to a blank page because we haven't created or implemented the Orders page yet, but what's key here is to look down in this area for Local Storage to see what data it's saving within the browsers. So, as I click on Apple Pie, you'll notice it creates an order and has all that information there for the Apple Pie order. If I go back and select on Cherry Pie, it saves the information about the Cherry Pie. So let's go back to the page, and now we'll go to Sources, and I'll create a break point inside the DOMContentLoaded event handler. I'll also create a break point inside the click event listener for each one of the buttons, and then we'll be able to watch as this script executes. So now let me reload the page, and you'll notice I've hit a break point here inside DOMContentLoaded. So it's running the selector for all the buttons that have the data‑order attribute. I allow that to run, and inspect, you can see that I've got two buttons, one for the Cherry Pie and one for the Apple Pie. Now this sets up the event listener for each one of the Order buttons, so I can click on Resume script execution, and it sets up that click event handler. Now I can click on one of the buttons, and it stops here within the code that's handling the click event. First, I'll get reference to the button, and then I get reference to the parent node. So you can see that the button is right here, and its parent container is the div above it. Now in order to create my order object, I'll look at the button and get the value of the data‑order attribute, as well as the divs for title, price, and description, and get the innerText value out of those, and set them equal to the properties in my object. So now when I take a look at the order object, you can see that it's got to property for each one of those values, and the values have been extracted out of the web page. So let's take a look at what JSON.stringify is doing for a moment. So here I have my order object, which is a full object. That means I can click on this drop‑down, and I can see the individual properties, I can go order.description, if I spell it right, and pull out the description, but really what I want to do is save all of this as a string. So I can use json.stringify, and pass in my order object, and that creates a string of that entire object. So I create a string, or what we call in programming, I serialize that object down into a string and can set that into Local Storage. So if I go into Local Storage, you can see I selected on the Apple Pie button, and that's now saved here within the storage. Now looking at the current window.location.href value, I have my local server and then pies.html, and I can run the replace function of a string, and replace pies.html for order.html. As I run that, you can see that the new location that I have available is the local server/order.html, and so I tell the browser's window location to be set to that new value, and that forwards the browser to our Order page. So now let's talk about HTML input forms and the geolocation API, so we can implement the Orders page.

HTML Forms
HTML forms give us as developers a way to collect user information on a website. Now, forms serve at least two purposes. The first is to provide elements on the page where users can interact by typing in their information, and these are called input elements. The second is to package up all this information and send it somewhere. Now, you can either use built‑in features to send this data to the server, or you can handle this process manually. To keep things simple, I'm going to use the built‑in approach for this course, but note that the subject of forms is vast, and we're just covering but a few of the features here. Forms are composed of the HTML form element with a number of input elements nested inside it. There are two important attributes that you need to know about when using forms. The action attributes tells the web browser which location to send the form data. Once you collect the data, you need to store it or process it somehow. So you enter a URL here that points to the place that knows how to read the data you send it. The request method tells the browser how to format the message that it sends to the server. Right now, all you need to know is that this value is going to be POST. Posting means that you're telling the server that you're sending it some data for it to process. Inside a form, you have a series of input elements. Here there's a text box which allows a user to enter in their full name. The ID and name attributes are important because this is how the browser and the server identify the information sent. There's some historical reasons why we use both the ID and name attributes, but suffice it to say, you want to pick an identifier unique to the page and use that value for both the name and ID attributes. And lastly, the form has a Submit button. By adding a button where the type is equal to submit, the form is set up to take all the data entered into the input forms and send it to the destination defined in the action attribute. All right, well, let's return to the editor and create the order page and set up our input form.

Order Page: Create the Page
Returning back to the editor, I need to get a foundation set up for my Order page. So just like we've done in the past, I'll go over to the home page, which is index.html, and I'll copy all of the code here for this page, and paste it into my order.html page. So Ctrl+Shift+s, or Command+Shift+s on a Mac, and then Ctl or Command+c to copy all of that text. Then I'll go over to order.html, and paste all of that code. Now I don't want all of it, so everything inside the article element, I'll select and delete, and then I'll also remove all the page‑specific styles. So now when we open up this page in Live Server, I'll use Command+ Shift+p and say Open with Live Server. We get the Order page with nothing on it. So this is the starting point we want to work from. Now we'll start by adding in the form.

Order Page: Add the Input Form
Now that we have our newly created order page, we can start adding in the form. Before that, though, I want to give a title to the page, so let's add that here. So I've given it an h1 header and titled the page Order. So now we'll start by adding in the form element. So here is our form element. The action attribute points to a local server that I have running on my machine. This is an example service that reports back the data that we've submitted to it. In the real world, as you create your applications, you'll have a different type of URL here that points to a server that knows how to collect and use this data. And of course, we have the method of POST. Now I've added our first group of elements that help with collecting user input. So first, let's talk about the input element here. Just like you saw on the slides, I've created an input type of text and given it the same value for name and ID. Associated with this input element is the label element. I'll show you this in a browser in a moment, but by adding a value for the for attribute and making that match the ID of our input element, if you click on this text, it'll put your cursor inside the text box, it's a really handy feature, and then to put them both inside a div element and giving them a class of input group so I can style them appropriately. We'll get to the styles for our form in the next clip, but first, let's take a look at how this input group looks in the browser. So here it rendered first name in the First name text box. Now, since I created that label with the attribute of for that points to the same value as the ID for my text box, when I click on that label, it brings focus and adds the cursor into the text box. So now I'll go through and add that same type of grouping for each one of the elements that we need within our form. Here is the group for the last name element, and now we'll add one for address. So this is an input element for the street address. So now what I want to do is create a drop‑down list that will allow people to choose from US states. Now there is a couple states to choose from like 50 of them so that's why I want to add in a drop‑down list so people can choose them without having to type out the text. The construction here is the same. I have a div element that's the container with a class of input group, as well as a label for the state, and then now instead of a text input type, I have a select box. So here, the element has a name of state, an ID of state, and then a series of option values inside the select element. I've preselected the first one to say Select one and then I've added in each one of the states in alphabetical order. Let's take a look in the browser of what it looks like now. And so now I have my first name, last name, street address, and my state drop‑down. Alright, let's keep going. At the end of my state container, I can add in the elements that I need for postal code. So this is back to the same setup that we had for the first name, last name, and street address elements. Now I want to be able to give a place for people to add in comments or free form text box to type in a message to Bethany, so let's add in a textarea element next. A textarea element is a little bit different than our normal input text because it gives you a chance to add multiline text. So let's save these changes and take a look at it in the browser. So with a textarea element, we have this Comments box and I can come in and type any sort of free form message I want, it's multiline and it works really great. So within the textarea, you give it the name and ID, and then you can give it some size dimensions so you tell it how many columns and how many rows that you want, so these values give you the size that you saw within the browser. Now the last thing that we need within our form is a couple buttons and so we'll add those now. So I've added two buttons to the page. The first one is the Reset button and the next one is a Submit button. Let's go back to the browser for a moment so you can see the behavior of the two buttons. The Reset button clears the form and takes it back to an empty state. So if I type in a name and I type in some comments, but I don't like the values I've put in, I can hit Reset and everything gets cleared out. The Order button is a Submit button, which you saw within the slides, when you click on that, that takes all of the information within the form, packages it up, and sends it to the destination defined in the action attribute. So to get that behavior, the Reset button has a type of reset and the Submit button has a type of submit. So that's all the markup that we need for our form, however, it's not looking very pretty. So in the next clip, we'll add in the CSS rules specific to this page in order to make our form look much more presentable.

Order Page: Form Styles
So right now our order form looks like this, and we want it to look a little more like this. Now even this view isn't the final version, we still want to make sure that we have a picture of the pie selected, and all of the description, and title, and price information, but as far as the form is concerned, we want our form to look more like this than like this. So now what we'll do is add in the style rules into the order.html page in order to make the form look a little more presentable. Starting at the top of the page, right underneath the link element, I'll create a style element. Now the first thing that we want to do is give some style to the input‑group class. This adds bottom margin to each one of the input‑group containers. So if we save the file, you can see now each one of the elements are spaced apart from each other a little bit nicer. Next I want to add a rule that updates the look and feel of each one of the input elements. So I want to give it some padding, change the border color, round the corners, and give it the right width. Now the rule that I'll add in here will apply to many different input elements all at once. So here I'm looking at elements inside the input‑group container, I'm looking for input elements, the textarea, and the select drop‑down list. So now when I save these changes, you can see that they all look a little bit better, and if I go into type inside one, you'll notice that the padding is showing up because the text isn't right up against the border of the input element. Now let's make our labels look a little bit better. So right here, this label of First name, let's make that bold. So here I set the font‑weight equal to 600, which makes the text bold. And now I can add a style that's specific to the Reset button. Here I'm using an attribute type selector in order to target the Reset button for type= reset. Then in order to make it look like a link, I clear out the background, remove the border, set text‑decoration equal to underline to make it look like a link, and make it so when you mouse over the button, the cursor turns in to a hand using cursor pointer rather than just a regular arrow pointer. And lastly, I'll add in a style for the Submit button. Using a similar method as I did with the Reset button, I'm targeting an input element with a type of submit. I'll give it a border, round off the corners, and then add in some padding so that that button is easier to click on. So let's save these changes, and now you can see that we have a much more prominent Order button on the page. So now that our page is set up and our form is ready to go, we can start implementing the JavaScript on this page in order to read in the order information, so we can submit orders. So we'll look at doing that next.

Order Page: Selection Markup
So, I wanted to return back to the finished product, the fully implemented website, in order to review a little bit of functionality that we'll be adding in. So when I go to the pies page, it shows me these containers that have the image, description, title, all the information about the pies. And when I click on the Order button, it shows that same information on the order page, except now the Order button is gone. So next, we'll add in the HTML to the order page that shows the selection the customer made for the pie they want to order. So here we are, back in the order page with all of our work in progress. So let's scroll down to just past the title on the page, and right in between the title and the order form is where I want to add the HTML elements to show what a customer has ordered. And this is the exact same markup that we had on the list page, except now there's no Order button. Now we'll implement the behavior in order to give our image tag proper source attribute, and also values for title, price, and description. So now let's go down and start implementing that script. I'll scroll down to the bottom of the page, and just under the body element, I'll add in a script tag. So this is the starting point for our scripts, and so next we'll add in the script that allows us to handle the DOMContentLoaded event.

Order Page: Load Script
Now we want our script to run as the page loads, so we'll begin by handling the DOM content loaded event. Just as you've seen in the past, handling DOM content loaded ensures that our page is loaded and all the HTML elements are ready to go in memory for us to begin working with them. Now, the first order of business is to get the pie order information out of local storage. So to do that, I call getItem off of local storage and pass in the key. Now the result of getItem will go into order. Now for the rest of my code, I want to make sure I'm only executing if I have data for that order. So next, I'll add an if statement to make sure I'm working with actual data. So here, I'm leaning on the conventions of the JavaScript language in order to make my code easier to read. So by just passing in order as the expression for my if statement, JavaScript is asking whether or not the order variable has truthiness to it. Now, I know that sounds really weird, but that's the term that we use within JavaScript to describe this type of situation. So as it evaluates order, if it has a value, if it's not null or not undefined, then this will evaluate to true, but if what comes back from getItem is null or undefined, this if statement evaluates to false. So this is a very easy way to determine whether or not we have data inside my order variable. Now if you remember, the order information got turned into a string. We serialize that order information and put it in the local storage., so now we need to do the opposite of that. We need to take that string and turn it into a real object. So by running JSON.parse against the string representation of my order, now we can get a fully fledged pieOrder object. And so now that I have my order data, I can update the page to show this information back to the user. If we take a look at the HTML again, we have this div that's a container for all of the elements and it has a class of pie. So we'll use a selector to go against this class name in order to get reference to this container. So here, I can use document.querySelector and pass in the pie class selector in order to get reference to that container. Now that I have that, I can show the user the image, the title, price, and description. So using the pie container as my foundation, I can look for elements that have the title class, the price class, and the description class inside that pie container. And so once I have reference to those elements, I can update their inner text property with the values from my pie order object. So here, for each one of those elements, I can use the innerText property and pointed to the appropriate property within the pieOrder object. Now, if this doesn't make sense at this point, don't worry about it, we'll be stepping through the code in a minute and you'll see this running line by line. So now let's add the script that we need in order to show the appropriate image on the page. Once again, I'm looking at the pie container and selecting for the image element that's found within that container. Once I have that, then I can update its source attribute. Here, I can use setAttribute to set the source attribute equal to images/pieOrder.id.png. So inside my images folder, I have an image for applepie.png and cherry‑pie.png. The order ID that comes over inside the object will match either apple‑pie or cherry‑pie, and that came ultimately from the data‑attribute of the button that we clicked on. And then I can just add in some text for the alt attribute so that if you mouse over the image, you can see the title and this sets up that alt attribute and adds in the title for the pieOrder to the image. So now let's look at this running in the browser and you can see how this all works together.

Order Page: Display Order Info
In order for the orders page to work correctly, we need to have selected a pie to order. So here I am back in the work‑in‑progress version of the website on the pies list page. So let's select cherry pie, and then we'll hit a break point inside the orders page. So notice now our container right now is blank. That'll change in just a moment. Here we've hit the break point for DOMContentLoaded, and so this script is running as the page loads. The first thing that we do is call getItem on local storage, and so when we run that, you can see that we have an order for the page. So, this is the order that we've created, but it's all in string format. This evaluates to true because there is a value for our order variable. And now we can use JSON.parse against the serialized version of our order in order to create the object version of it. So now it's been parsed, and now I have a full object for the order. So next, we'll select the container for the pie. You can see that now that box is selected. Inside the box, we can select the elements for title, price, and description. So we have title, price, and description, and now we can add values into each one of those elements. So by using the innerText property and the pieOrder.title value, we can give the title its value, the price, and the description all get what they need from the script. Lastly, we just have to add in the image, so we get reference to the image inside the container. When we look at the pieOrder, the id is cherry‑pie, so we pass that into the string in order to create images/cherry‑pie.png, and set that equal to the source attributes. You won't see that immediately because it needs to load from the server. Then we can set the alt attribute, and now when I set this to run, the image loads in, and we have all the information that we need to show the order selection to the user. Now we're missing one style rule that's specific for our desktop layout, so let's add that now. So back in the orders.html page, I'll add in a rule that uses a media query that targets just desktop layouts. So here we're telling the article element only for desktop layouts, or layouts that are a minimum width of 768px, that the width of the article element needs to be 350px. So we'll save this change, and now the order page looked much more like what we're expecting.

Order Page: Hidden Order Input
So we have the order information being displayed on the page and that's great, and if we go and fill out the form and click on the Order button, we have a bit of a problem. Now, right now I have this page pointing to a utility service on my machine that just takes the order information that we sent to the server and displays it back on the screen. So we have the contact information, but there is nothing here to indicate what the order information is, the fact that we picked a cherry pie. So what we'll do is update the form to have a hidden field that can take in that order information and send it off to the server. In the order file, we'll scroll down to right underneath the form element. So here within the form, I'll add in a hidden input element. Now this is hidden because there is no visual representation of this element on the screen. All this is is an input element to add into the form where we can take data and pass it to the server. So here, it has the ID of pie‑order, and so now in my script, I can take the order information and add it into this input element. So let's go down to the script portion of the page now. So once we verify that we have our order, we can add in another selector that gets referenced to that hidden input element. So this uses document.querySelector and passes in the selector of an ID value of pie‑order, which is what we had for the hidden input element. And so now, we can just take this string representation of that order and set it equal to the input's value. So this takes the order string, remember, this isn't the parsed version of it, it's just the string and set that equal to the input order's value. So let's save that change and go back to the form and take a look at what's sent to the server now. So now, with the new input element and our update to the script, once the form is filled out, we can come over, press on Order, and the server now sees the order information coming from that hidden input element. Now we have just one last feature to implement into Bethany's Pie Shop and that's the geolocation request, so let's take a look at that API next.

Geolocation API
The geolocation API gives you a chance to ask your users if they'd like to share location data with your application. When you navigate to a page using the API, the browser prompts the site visitor and asks them if they'd like to share their location. If approved, your app can get access to information like the user's latitude and longitude data. Now be advised, sometimes the location data doesn't always return pinpoint accurate results and reasons for variations and accuracy spread from if a user is connected to a Wi‑Fi network or if you only ask for location once like we're doing here. But for now, this gives you a chance to use a more advanced feature of HTML APIs. So the syntax for geolocation is found off the window.navigator.geolocation object. From there, you can call the getCurrentPosition function to request permission to access the user's location data. If they grant permission, then you get to read the data, otherwise, the function exposes an error. To account for the success in error situations, we need a few anonymous functions as arguments. The anonymous functions are often referred to as callbacks because getCurrentPosition is calling back to the anonymous function with a response. So to make room for these callbacks, the ending parentheses and the semicolon are moving a few lines down to make space. Then we add a function for when permission is granted and one for either when permission is denied or there was some other type of error. Inside the success callback, the position argument is filled with information about the user's location. By accessing the cords object, you get values for latitude and longitude, and if something doesn't go quite right, you can add logic into the error callbacks to deal with it. So now that you have an idea of what's involved, let's return to the app and add in the request for location data.

Order Page: Add Geolocation
Now it's getting a little harder to tell the difference between the development version and the finished version because we're almost finished building this website. but this is the finished version of the website ,and there's one thing that I want to show you before we move on. So if I click on the Order button, that takes us to the Order page, and we get this prompt at the top of the browser asking whether or not we want to share our location. For now, I'm going to allow it, and then I'll fill out the form. With the form filled out, we can scroll down to the bottom, and submit the order. Now you'll notice that this server utility that I have is reporting back the data that is sent to the server. So we have our pie order information and our contact details, but we also have location information, and I'm showing you this here in order to make the point that we need to have a hidden input element in our form to send the location data down to the server. So let's switch back to the editor, and we'll add that input element to the form next So here we are inside orders.html, and what we need to do is go down and find the form on the page. So right underneath the first input hidden element, I'll create a new one for the location. So the id for this one is location, and we'll use that value in our selector inside our script so that we can give a value to this input element. All right, let's go down to the JavaScript on the page at the bottom now. So inside the DOMContentLoaded event, one of the first things that we'll do is get reference to the location hidden input element box. So here we use document.querySelector, and add in a selector for the id of location. So this gives us the reference to the hidden input element. Next, I want to create a variable that will hold the latitude and longitude values for us. So here I've created the location object. I've created two properties, one for latitude and one for longitude, and I've given them what are called default values or basically starter values of unknown. That way, if there's an error or if the user decides not to share their location information, we at least have the value of unknown inside of each one of these properties. Now we can add in the call to getCurrentPosition in order to prompt the user for permission to read their location. So here we're calling window.navigator.geolocation.getCurrentPosition. Now if you recall correctly, getCurrentPosition has two callbacks to it, one for the success state and one for the error state. So here are those two callbacks. Now notice that after getCurrentPosition, I have an open parentheses, and then down here on line 198, I have the close parentheses and the semicolon. In between those, I have two callbacks, or two anonymous functions. The first one will have an argument for the position. This is provided only if the user has chosen to allow their location to be shared with the application. If they deny permission or there's any other type of error, the error callback will be called. So now we just have to add in some logic of what to do within each one of these cases. If we've been granted permission, then we want to take the location information and set it aside into our location object. So here we have a couple of lines of code that look at the position object, and then the coords object, and then read out the latitude and longitude values. Now that we have those values set aside in to our object, we can serialize that object and set it equal to the value of our hidden input. So now the location box has the value of our location, and if there's an error, it's the same line of code, all that's happening here is we're taking our default values of unknown, serializing them, and setting them inside the box. And with this line of code, we fully implemented Bethany's website. All right, well, in the next clip, I'll set some break points, and you can see the data as it flows through the code.

Step Through Geolocation Code
Starting from the pies list page, we'll select one of the pies to order, so here we'll pick Cherry Pie. Now I've said some break points, and here we are stopping in DOMContentLoaded, and the first line of code it's going to run is the line that gets referenced to our hidden input element for the locationBox. So you can see that we have reference to that here now, and then I'm creating a new object called location, and it'll have some default values of unknown for both latitude and longitude. Now, as line 229 is run, it will request the CurrentPosition from the browser. So I'm going to press this button here to let the script run, and now you'll notice that I have the dialogue that shows up at the top of the browser screen. Now first let's take a look at what happens if you deny the request. So I'm going to Block this request for location. It comes down to the error handler or the error callback, and you can see that all we're going to do is take our default values for latitude and longitude, and set it equal to the value of our locationBox. So we'll do that, and now that's serialized into the hidden input element. All right, I'm going to let this run, and we'll refresh the page, and do this over again. In development, when you want to test the different scenarios when working with location data, if you click on either the lock if you have a secure server or little icon here, you can see that Location is set to Block, and I can switch it back to Ask for default. And now I can reload the page, and we can try that again. So I'll let the script run, now it's asking for my location information again, and this time I'll allow it. Now when we take a look at the position, you can see that we have values for coordinates, and inside here we have a number of different values, accuracy, and altitude, heading, but what we're most interested in is latitude and longitude. So we can take those values and add them into our custom object, and then serialized the value and stick it into the locationBox. So as the rest of the script runs on this page, it reports back to us the pie that we are ordering, now I'll fill out the form, and then scroll down to the bottom, and press the Order button, and now we have pie order information, location information, and all the contact information needed to create an order to Bethany's Pie Shop. And with that, the website is fully implemented with layouts for mobile devices, desktop devices, we're reading location information, taking customer information, and forwarding all of that to the server for processing. Congratulations on this huge step in your journey to becoming a professional web developer.

Conculsion
Well, once again, I want to say congratulations on completing this course. I am truly honored to have spent this time with you, and I wish you all the best as you build your career in web development. I encourage you to continue working through the associated courses in this path, and please do get in touch with me on Twitter and let me know how you're doing. Let's do this again real soon.